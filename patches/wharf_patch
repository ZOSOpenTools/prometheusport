diff --git a/go_package_port/github.com/edsrzf/mmap-go/.github/workflows/build-test.yml b/go_package_port/github.com/edsrzf/mmap-go/.github/workflows/build-test.yml
new file mode 100644
index 0000000..8b34b37
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/.github/workflows/build-test.yml
@@ -0,0 +1,19 @@
+name: Build and Test
+on: [push]
+jobs:
+  run:
+    runs-on: ${{ matrix.operating-system }}
+    strategy:
+      matrix:
+        operating-system: [ubuntu-latest, windows-latest, macos-latest]
+    steps:
+    - name: Checkout
+      uses: actions/checkout@v2
+    - name: Setup Go
+      uses: actions/setup-go@v2
+      with:
+        go-version: '~1.17.0'
+    - name: Build
+      run: go build .
+    - name: Test
+      run: go test ./...
diff --git a/go_package_port/github.com/edsrzf/mmap-go/.gitignore b/go_package_port/github.com/edsrzf/mmap-go/.gitignore
new file mode 100644
index 0000000..6c694e4
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/.gitignore
@@ -0,0 +1,11 @@
+*.out
+*.5
+*.6
+*.8
+*.swp
+_obj
+_test
+testdata
+/.idea
+*.iml
+/notes.txt
diff --git a/go_package_port/github.com/edsrzf/mmap-go/LICENSE b/go_package_port/github.com/edsrzf/mmap-go/LICENSE
new file mode 100644
index 0000000..8f05f33
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/LICENSE
@@ -0,0 +1,25 @@
+Copyright (c) 2011, Evan Shaw <edsrzf@gmail.com>
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+    * Neither the name of the copyright holder nor the
+      names of its contributors may be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
diff --git a/go_package_port/github.com/edsrzf/mmap-go/README.md b/go_package_port/github.com/edsrzf/mmap-go/README.md
new file mode 100644
index 0000000..1ac39f7
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/README.md
@@ -0,0 +1,14 @@
+mmap-go
+=======
+![Build Status](https://github.com/edsrzf/mmap-go/actions/workflows/build-test.yml/badge.svg)
+[![Go Reference](https://pkg.go.dev/badge/github.com/edsrzf/mmap-go.svg)](https://pkg.go.dev/github.com/edsrzf/mmap-go)
+
+mmap-go is a portable mmap package for the [Go programming language](http://golang.org).
+
+Operating System Support
+========================
+This package is tested using GitHub Actions on Linux, macOS, and Windows. It should also work on other Unix-like platforms, but hasn't been tested with them. I'm interested to hear about the results.
+
+I haven't been able to add more features without adding significant complexity, so mmap-go doesn't support `mprotect`, `mincore`, and maybe a few other things. If you're running on a Unix-like platform and need some of these features, I suggest Gustavo Niemeyer's [gommap](http://labix.org/gommap).
+
+This package compiles on Plan 9, but its functions always return errors.
diff --git a/go_package_port/github.com/edsrzf/mmap-go/example_test.go b/go_package_port/github.com/edsrzf/mmap-go/example_test.go
new file mode 100644
index 0000000..f8820fb
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/example_test.go
@@ -0,0 +1,56 @@
+package mmap_test
+
+import (
+	"fmt"
+	"log"
+	"os"
+
+	"github.com/edsrzf/mmap-go"
+)
+
+func ExampleMapRegion() {
+	m, err := mmap.MapRegion(nil, 100, mmap.RDWR, mmap.ANON, 0)
+	if err != nil {
+		log.Fatal(err)
+	}
+	// m acts as a writable slice of bytes that is not managed by the Go runtime.
+	fmt.Println(len(m))
+
+	// Because the region is not managed by the Go runtime, the Unmap method should
+	// be called when finished with it to avoid leaking memory.
+	if err := m.Unmap(); err != nil {
+		log.Fatal(err)
+	}
+
+	// Output: 100
+}
+
+func ExampleMap() {
+	f, err := os.OpenFile("notes.txt", os.O_RDWR|os.O_CREATE, 0755)
+	if err != nil {
+		log.Fatal(err)
+	}
+	_, err = f.WriteString("Hello, world")
+	if err != nil {
+		log.Fatal(err)
+	}
+	// The file must be closed, even after calling Unmap.
+	defer f.Close()
+
+	m, err := mmap.Map(f, mmap.RDWR, 0)
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	// m acts as a writable slice of bytes that is a view into the open file, notes.txt.
+	// It is sized to the file contents automatically.
+	fmt.Println(string(m))
+
+	// The Unmap method should be called when finished with it to avoid leaking memory
+	// and to ensure that writes are flushed to disk.
+	if err := m.Unmap(); err != nil {
+		log.Fatal(err)
+	}
+
+	// Hello, world
+}
diff --git a/go_package_port/github.com/edsrzf/mmap-go/go.mod b/go_package_port/github.com/edsrzf/mmap-go/go.mod
new file mode 100644
index 0000000..0e3a64a
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/go.mod
@@ -0,0 +1,5 @@
+module github.com/edsrzf/mmap-go
+
+go 1.17
+
+require golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e
diff --git a/go_package_port/github.com/edsrzf/mmap-go/go.sum b/go_package_port/github.com/edsrzf/mmap-go/go.sum
new file mode 100644
index 0000000..198c4e4
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/go.sum
@@ -0,0 +1,4 @@
+golang.org/x/sys v0.0.0-20181221143128-b4a75ba826a6 h1:IcgEB62HYgAhX0Nd/QrVgZlxlcyxbGQHElLUhW2X4Fo=
+golang.org/x/sys v0.0.0-20181221143128-b4a75ba826a6/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
+golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e h1:fLOSk5Q00efkSvAm+4xcoXD+RRmLmmulPn5I3Y9F2EM=
+golang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
diff --git a/go_package_port/github.com/edsrzf/mmap-go/mmap.go b/go_package_port/github.com/edsrzf/mmap-go/mmap.go
new file mode 100644
index 0000000..29655bd
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/mmap.go
@@ -0,0 +1,117 @@
+// Copyright 2011 Evan Shaw. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// This file defines the common package interface and contains a little bit of
+// factored out logic.
+
+// Package mmap allows mapping files into memory. It tries to provide a simple, reasonably portable interface,
+// but doesn't go out of its way to abstract away every little platform detail.
+// This specifically means:
+//	* forked processes may or may not inherit mappings
+//	* a file's timestamp may or may not be updated by writes through mappings
+//	* specifying a size larger than the file's actual size can increase the file's size
+//	* If the mapped file is being modified by another process while your program's running, don't expect consistent results between platforms
+package mmap
+
+import (
+	"errors"
+	"os"
+	"reflect"
+	"unsafe"
+)
+
+const (
+	// RDONLY maps the memory read-only.
+	// Attempts to write to the MMap object will result in undefined behavior.
+	RDONLY = 0
+	// RDWR maps the memory as read-write. Writes to the MMap object will update the
+	// underlying file.
+	RDWR = 1 << iota
+	// COPY maps the memory as copy-on-write. Writes to the MMap object will affect
+	// memory, but the underlying file will remain unchanged.
+	COPY
+	// If EXEC is set, the mapped memory is marked as executable.
+	EXEC
+)
+
+const (
+	// If the ANON flag is set, the mapped memory will not be backed by a file.
+	ANON = 1 << iota
+)
+
+// MMap represents a file mapped into memory.
+type MMap []byte
+
+// Map maps an entire file into memory.
+// If ANON is set in flags, f is ignored.
+func Map(f *os.File, prot, flags int) (MMap, error) {
+	return MapRegion(f, -1, prot, flags, 0)
+}
+
+// MapRegion maps part of a file into memory.
+// The offset parameter must be a multiple of the system's page size.
+// If length < 0, the entire file will be mapped.
+// If ANON is set in flags, f is ignored.
+func MapRegion(f *os.File, length int, prot, flags int, offset int64) (MMap, error) {
+	if offset%int64(os.Getpagesize()) != 0 {
+		return nil, errors.New("offset parameter must be a multiple of the system's page size")
+	}
+
+	var fd uintptr
+	if flags&ANON == 0 {
+		fd = uintptr(f.Fd())
+		if length < 0 {
+			fi, err := f.Stat()
+			if err != nil {
+				return nil, err
+			}
+			length = int(fi.Size())
+		}
+	} else {
+		if length <= 0 {
+			return nil, errors.New("anonymous mapping requires non-zero length")
+		}
+		fd = ^uintptr(0)
+	}
+	return mmap(length, uintptr(prot), uintptr(flags), fd, offset)
+}
+
+func (m *MMap) header() *reflect.SliceHeader {
+	return (*reflect.SliceHeader)(unsafe.Pointer(m))
+}
+
+func (m *MMap) addrLen() (uintptr, uintptr) {
+	header := m.header()
+	return header.Data, uintptr(header.Len)
+}
+
+// Lock keeps the mapped region in physical memory, ensuring that it will not be
+// swapped out.
+func (m MMap) Lock() error {
+	return m.lock()
+}
+
+// Unlock reverses the effect of Lock, allowing the mapped region to potentially
+// be swapped out.
+// If m is already unlocked, aan error will result.
+func (m MMap) Unlock() error {
+	return m.unlock()
+}
+
+// Flush synchronizes the mapping's contents to the file's contents on disk.
+func (m MMap) Flush() error {
+	return m.flush()
+}
+
+// Unmap deletes the memory mapped region, flushes any remaining changes, and sets
+// m to nil.
+// Trying to read or write any remaining references to m after Unmap is called will
+// result in undefined behavior.
+// Unmap should only be called on the slice value that was originally returned from
+// a call to Map. Calling Unmap on a derived slice may cause errors.
+func (m *MMap) Unmap() error {
+	err := m.unmap()
+	*m = nil
+	return err
+}
diff --git a/go_package_port/github.com/edsrzf/mmap-go/mmap_plan9.go b/go_package_port/github.com/edsrzf/mmap-go/mmap_plan9.go
new file mode 100644
index 0000000..e4c33d3
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/mmap_plan9.go
@@ -0,0 +1,27 @@
+// Copyright 2020 Evan Shaw. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package mmap
+
+import "syscall"
+
+func mmap(len int, inprot, inflags, fd uintptr, off int64) ([]byte, error) {
+	return nil, syscall.EPLAN9
+}
+
+func (m MMap) flush() error {
+	return syscall.EPLAN9
+}
+
+func (m MMap) lock() error {
+	return syscall.EPLAN9
+}
+
+func (m MMap) unlock() error {
+	return syscall.EPLAN9
+}
+
+func (m MMap) unmap() error {
+	return syscall.EPLAN9
+}
diff --git a/go_package_port/github.com/edsrzf/mmap-go/mmap_test.go b/go_package_port/github.com/edsrzf/mmap-go/mmap_test.go
new file mode 100644
index 0000000..c4923a4
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/mmap_test.go
@@ -0,0 +1,173 @@
+// Copyright 2011 Evan Shaw. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// These tests are adapted from gommap: http://labix.org/gommap
+// Copyright (c) 2010, Gustavo Niemeyer <gustavo@niemeyer.net>
+
+package mmap
+
+import (
+	"bytes"
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"testing"
+)
+
+var testData = []byte("0123456789ABCDEF")
+var testPath = filepath.Join(os.TempDir(), "testdata")
+
+func init() {
+	f := openFile(os.O_RDWR | os.O_CREATE | os.O_TRUNC)
+	f.Write(testData)
+	f.Close()
+}
+
+func openFile(flags int) *os.File {
+	f, err := os.OpenFile(testPath, flags, 0644)
+	if err != nil {
+		panic(err.Error())
+	}
+	return f
+}
+
+func TestUnmap(t *testing.T) {
+	f := openFile(os.O_RDONLY)
+	defer f.Close()
+	mmap, err := Map(f, RDONLY, 0)
+	if err != nil {
+		t.Errorf("error mapping: %s", err)
+	}
+	if err := mmap.Unmap(); err != nil {
+		t.Errorf("error unmapping: %s", err)
+	}
+}
+
+func TestReadWrite(t *testing.T) {
+	f := openFile(os.O_RDWR)
+	defer f.Close()
+	mmap, err := Map(f, RDWR, 0)
+	if err != nil {
+		t.Errorf("error mapping: %s", err)
+	}
+	defer mmap.Unmap()
+	if !bytes.Equal(testData, mmap) {
+		t.Errorf("mmap != testData: %q, %q", mmap, testData)
+	}
+
+	mmap[9] = 'X'
+	mmap.Flush()
+
+	fileData, err := ioutil.ReadAll(f)
+	if err != nil {
+		t.Errorf("error reading file: %s", err)
+	}
+	if !bytes.Equal(fileData, []byte("012345678XABCDEF")) {
+		t.Errorf("file wasn't modified")
+	}
+
+	// leave things how we found them
+	mmap[9] = '9'
+	mmap.Flush()
+}
+
+func TestProtFlagsAndErr(t *testing.T) {
+	f := openFile(os.O_RDONLY)
+	defer f.Close()
+	if _, err := Map(f, RDWR, 0); err == nil {
+		t.Errorf("expected error")
+	}
+}
+
+func TestFlags(t *testing.T) {
+	f := openFile(os.O_RDWR)
+	defer f.Close()
+	mmap, err := Map(f, COPY, 0)
+	if err != nil {
+		t.Errorf("error mapping: %s", err)
+	}
+	defer mmap.Unmap()
+
+	mmap[9] = 'X'
+	mmap.Flush()
+
+	fileData, err := ioutil.ReadAll(f)
+	if err != nil {
+		t.Errorf("error reading file: %s", err)
+	}
+	if !bytes.Equal(fileData, testData) {
+		t.Errorf("file was modified")
+	}
+}
+
+// Test that we can map files from non-0 offsets
+// The page size on most Unixes is 4KB, but on Windows it's 64KB
+func TestNonZeroOffset(t *testing.T) {
+	const pageSize = 65536
+
+	// Create a 2-page sized file
+	bigFilePath := filepath.Join(os.TempDir(), "nonzero")
+	fileobj, err := os.OpenFile(bigFilePath, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
+	if err != nil {
+		panic(err.Error())
+	}
+
+	bigData := make([]byte, 2*pageSize, 2*pageSize)
+	fileobj.Write(bigData)
+	fileobj.Close()
+
+	// Map the first page by itself
+	fileobj, err = os.OpenFile(bigFilePath, os.O_RDONLY, 0)
+	if err != nil {
+		panic(err.Error())
+	}
+	m, err := MapRegion(fileobj, pageSize, RDONLY, 0, 0)
+	if err != nil {
+		t.Errorf("error mapping file: %s", err)
+	}
+	m.Unmap()
+	fileobj.Close()
+
+	// Map the second page by itself
+	fileobj, err = os.OpenFile(bigFilePath, os.O_RDONLY, 0)
+	if err != nil {
+		panic(err.Error())
+	}
+	m, err = MapRegion(fileobj, pageSize, RDONLY, 0, pageSize)
+	if err != nil {
+		t.Errorf("error mapping file: %s", err)
+	}
+	err = m.Unmap()
+	if err != nil {
+		t.Error(err)
+	}
+
+	m, err = MapRegion(fileobj, pageSize, RDONLY, 0, 1)
+	if err == nil {
+		t.Error("expect error because offset is not multiple of page size")
+	}
+
+	fileobj.Close()
+}
+
+func TestAnonymousMapping(t *testing.T) {
+	const size = 4 * 1024
+
+	// Make an anonymous region
+	mem, err := MapRegion(nil, size, RDWR, ANON, 0)
+	if err != nil {
+		t.Fatalf("failed to allocate memory for buffer: %v", err)
+	}
+
+	// Check memory writable
+	for i := 0; i < size; i++ {
+		mem[i] = 0x55
+	}
+
+	// And unmap it
+	err = mem.Unmap()
+	if err != nil {
+		t.Fatalf("failed to unmap memory for buffer: %v", err)
+	}
+}
diff --git a/go_package_port/github.com/edsrzf/mmap-go/mmap_unix.go b/go_package_port/github.com/edsrzf/mmap-go/mmap_unix.go
new file mode 100644
index 0000000..762e658
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/mmap_unix.go
@@ -0,0 +1,49 @@
+//go:build zos
+
+// Tags altered by Wharf (added zos)
+//
+package mmap
+
+import (
+	"golang.org/x/sys/unix"
+)
+
+func mmap(len int, inprot, inflags, fd uintptr, off int64) ([]byte, error) {
+	flags := unix.MAP_SHARED
+	prot := unix.PROT_READ
+	switch {
+	case inprot&COPY != 0:
+		prot |= unix.PROT_WRITE
+		flags = unix.MAP_PRIVATE
+	case inprot&RDWR != 0:
+		prot |= unix.PROT_WRITE
+	}
+	if inprot&EXEC != 0 {
+		prot |= unix.PROT_EXEC
+	}
+	if inflags&ANON != 0 {
+		flags |= unix.MAP_ANON
+	}
+
+	b, err := unix.Mmap(int(fd), off, len, prot, flags)
+	if err != nil {
+		return nil, err
+	}
+	return b, nil
+}
+
+func (m MMap) flush() error {
+	return unix.Msync([]byte(m), unix.MS_SYNC)
+}
+
+func (m MMap) lock() error {
+	return unix.Mlock([]byte(m))
+}
+
+func (m MMap) unlock() error {
+	return unix.Munlock([]byte(m))
+}
+
+func (m MMap) unmap() error {
+	return unix.Munmap([]byte(m))
+}
diff --git a/go_package_port/github.com/edsrzf/mmap-go/mmap_windows.go b/go_package_port/github.com/edsrzf/mmap-go/mmap_windows.go
new file mode 100644
index 0000000..e0d986f
--- /dev/null
+++ b/go_package_port/github.com/edsrzf/mmap-go/mmap_windows.go
@@ -0,0 +1,154 @@
+// Copyright 2011 Evan Shaw. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package mmap
+
+import (
+	"errors"
+	"os"
+	"sync"
+
+	"golang.org/x/sys/windows"
+)
+
+// mmap on Windows is a two-step process.
+// First, we call CreateFileMapping to get a handle.
+// Then, we call MapviewToFile to get an actual pointer into memory.
+// Because we want to emulate a POSIX-style mmap, we don't want to expose
+// the handle -- only the pointer. We also want to return only a byte slice,
+// not a struct, so it's convenient to manipulate.
+
+// We keep this map so that we can get back the original handle from the memory address.
+
+type addrinfo struct {
+	file     windows.Handle
+	mapview  windows.Handle
+	writable bool
+}
+
+var handleLock sync.Mutex
+var handleMap = map[uintptr]*addrinfo{}
+
+func mmap(len int, prot, flags, hfile uintptr, off int64) ([]byte, error) {
+	flProtect := uint32(windows.PAGE_READONLY)
+	dwDesiredAccess := uint32(windows.FILE_MAP_READ)
+	writable := false
+	switch {
+	case prot&COPY != 0:
+		flProtect = windows.PAGE_WRITECOPY
+		dwDesiredAccess = windows.FILE_MAP_COPY
+		writable = true
+	case prot&RDWR != 0:
+		flProtect = windows.PAGE_READWRITE
+		dwDesiredAccess = windows.FILE_MAP_WRITE
+		writable = true
+	}
+	if prot&EXEC != 0 {
+		flProtect <<= 4
+		dwDesiredAccess |= windows.FILE_MAP_EXECUTE
+	}
+
+	// The maximum size is the area of the file, starting from 0,
+	// that we wish to allow to be mappable. It is the sum of
+	// the length the user requested, plus the offset where that length
+	// is starting from. This does not map the data into memory.
+	maxSizeHigh := uint32((off + int64(len)) >> 32)
+	maxSizeLow := uint32((off + int64(len)) & 0xFFFFFFFF)
+	// TODO: Do we need to set some security attributes? It might help portability.
+	h, errno := windows.CreateFileMapping(windows.Handle(hfile), nil, flProtect, maxSizeHigh, maxSizeLow, nil)
+	if h == 0 {
+		return nil, os.NewSyscallError("CreateFileMapping", errno)
+	}
+
+	// Actually map a view of the data into memory. The view's size
+	// is the length the user requested.
+	fileOffsetHigh := uint32(off >> 32)
+	fileOffsetLow := uint32(off & 0xFFFFFFFF)
+	addr, errno := windows.MapViewOfFile(h, dwDesiredAccess, fileOffsetHigh, fileOffsetLow, uintptr(len))
+	if addr == 0 {
+		windows.CloseHandle(windows.Handle(h))
+		return nil, os.NewSyscallError("MapViewOfFile", errno)
+	}
+	handleLock.Lock()
+	handleMap[addr] = &addrinfo{
+		file:     windows.Handle(hfile),
+		mapview:  h,
+		writable: writable,
+	}
+	handleLock.Unlock()
+
+	m := MMap{}
+	dh := m.header()
+	dh.Data = addr
+	dh.Len = len
+	dh.Cap = dh.Len
+
+	return m, nil
+}
+
+func (m MMap) flush() error {
+	addr, len := m.addrLen()
+	errno := windows.FlushViewOfFile(addr, len)
+	if errno != nil {
+		return os.NewSyscallError("FlushViewOfFile", errno)
+	}
+
+	handleLock.Lock()
+	defer handleLock.Unlock()
+	handle, ok := handleMap[addr]
+	if !ok {
+		// should be impossible; we would've errored above
+		return errors.New("unknown base address")
+	}
+
+	if handle.writable && handle.file != windows.Handle(^uintptr(0)) {
+		if err := windows.FlushFileBuffers(handle.file); err != nil {
+			return os.NewSyscallError("FlushFileBuffers", err)
+		}
+	}
+
+	return nil
+}
+
+func (m MMap) lock() error {
+	addr, len := m.addrLen()
+	errno := windows.VirtualLock(addr, len)
+	return os.NewSyscallError("VirtualLock", errno)
+}
+
+func (m MMap) unlock() error {
+	addr, len := m.addrLen()
+	errno := windows.VirtualUnlock(addr, len)
+	return os.NewSyscallError("VirtualUnlock", errno)
+}
+
+func (m MMap) unmap() error {
+	err := m.flush()
+	if err != nil {
+		return err
+	}
+
+	addr := m.header().Data
+	// Lock the UnmapViewOfFile along with the handleMap deletion.
+	// As soon as we unmap the view, the OS is free to give the
+	// same addr to another new map. We don't want another goroutine
+	// to insert and remove the same addr into handleMap while
+	// we're trying to remove our old addr/handle pair.
+	handleLock.Lock()
+	defer handleLock.Unlock()
+	err = windows.UnmapViewOfFile(addr)
+	if err != nil {
+		return err
+	}
+
+	handle, ok := handleMap[addr]
+	if !ok {
+		// should be impossible; we would've errored above
+		return errors.New("unknown base address")
+	}
+	delete(handleMap, addr)
+
+	e := windows.CloseHandle(windows.Handle(handle.mapview))
+	return os.NewSyscallError("CloseHandle", e)
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/.editorconfig b/go_package_port/github.com/fsnotify/fsnotify/.editorconfig
new file mode 100644
index 0000000..fad8958
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/.editorconfig
@@ -0,0 +1,12 @@
+root = true
+
+[*.go]
+indent_style = tab
+indent_size = 4
+insert_final_newline = true
+
+[*.{yml,yaml}]
+indent_style = space
+indent_size = 2
+insert_final_newline = true
+trim_trailing_whitespace = true
diff --git a/go_package_port/github.com/fsnotify/fsnotify/.gitattributes b/go_package_port/github.com/fsnotify/fsnotify/.gitattributes
new file mode 100644
index 0000000..32f1001
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/.gitattributes
@@ -0,0 +1 @@
+go.sum linguist-generated
diff --git a/go_package_port/github.com/fsnotify/fsnotify/.github/ISSUE_TEMPLATE/bug_report.md b/go_package_port/github.com/fsnotify/fsnotify/.github/ISSUE_TEMPLATE/bug_report.md
new file mode 100644
index 0000000..82a6a1c
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/.github/ISSUE_TEMPLATE/bug_report.md
@@ -0,0 +1,33 @@
+---
+name: Bug report
+about: Create a report to help us improve
+title: ''
+labels: ''
+assignees: ''
+
+---
+
+Before reporting an issue, please ensure you are using the latest release of `fsnotify`, and please
+search for existing issue to avoid duplicates.
+
+**Describe the bug**
+A clear and concise description of what the bug is.
+
+**To Reproduce**
+Steps to reproduce the behavior:
+1. Go to '...'
+2. Click on '....'
+3. Scroll down to '....'
+4. See error
+
+**Expected behavior**
+A clear and concise description of what you expected to happen.
+
+**Which operating system and version are you using?**
+
+Linux: lsb_release -a
+macOS: sw_vers
+Windows: systeminfo | findstr /B /C:OS
+
+**Additional context**
+If applicable, add screenshots or a code sample to help explain your problem.
diff --git a/go_package_port/github.com/fsnotify/fsnotify/.github/ISSUE_TEMPLATE/feature_request.md b/go_package_port/github.com/fsnotify/fsnotify/.github/ISSUE_TEMPLATE/feature_request.md
new file mode 100644
index 0000000..bbcbbe7
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/.github/ISSUE_TEMPLATE/feature_request.md
@@ -0,0 +1,20 @@
+---
+name: Feature request
+about: Suggest an idea for this project
+title: ''
+labels: ''
+assignees: ''
+
+---
+
+**Is your feature request related to a problem? Please describe.**
+A clear and concise description of what the problem is. Ex. I'm always frustrated when [...]
+
+**Describe the solution you'd like**
+A clear and concise description of what you want to happen.
+
+**Describe alternatives you've considered**
+A clear and concise description of any alternative solutions or features you've considered.
+
+**Additional context**
+Add any other context or screenshots about the feature request here.
diff --git a/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/Vagrantfile.debian6 b/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/Vagrantfile.debian6
new file mode 100644
index 0000000..fbe8f08
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/Vagrantfile.debian6
@@ -0,0 +1,6 @@
+Vagrant.configure("2") do |config|
+  config.vm.box = "threatstack/debian6"
+  config.vm.box_version = "1.0.0"
+
+  config.vm.define 'debian6'
+end 
diff --git a/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/build.yml b/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/build.yml
new file mode 100644
index 0000000..4b20df6
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/build.yml
@@ -0,0 +1,27 @@
+name: 'build'
+on:
+  push:
+    paths: ['**.go', 'go.mod', '.github/workflows/*']
+
+jobs:
+  cross-compile:
+    strategy:
+      fail-fast: false
+      matrix:
+        go: ['1.16', '1.19']
+    runs-on: ubuntu-latest
+    steps:
+      - name: setup Go
+        uses: actions/setup-go@v3
+        with:
+          go-version: ${{ matrix.go }}
+
+      - name: checkout
+        uses: actions/checkout@v3
+
+      - name: build
+        run: |
+          set -x
+          for a in $(go tool dist list); do
+            GOOS=${a%%/*} GOARCH=${a#*/} go build
+          done
diff --git a/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/staticcheck.yml b/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/staticcheck.yml
new file mode 100644
index 0000000..fdc031d
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/staticcheck.yml
@@ -0,0 +1,16 @@
+name: 'staticcheck'
+on:
+  push:
+    paths: ['**.go', 'go.mod', '.github/workflows/*']
+
+jobs:
+  staticcheck:
+    name:    'staticcheck'
+    runs-on: ubuntu-latest
+    steps:
+    - uses: actions/checkout@v3
+      with:
+        fetch-depth: 1
+    - uses: dominikh/staticcheck-action@v1.2.0
+      with:
+        version: '2022.1'
diff --git a/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/test.yml b/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/test.yml
new file mode 100644
index 0000000..89f6c6d
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/.github/workflows/test.yml
@@ -0,0 +1,162 @@
+name: 'test'
+on:
+  push:
+    paths: ['**.go', 'go.mod', '.github/workflows/*']
+
+jobs:
+  # Test Windows and Linux with the latest Go version and the oldest we support.
+  test:
+    strategy:
+      fail-fast: false
+      matrix:
+        os:
+          - ubuntu-latest
+          - windows-latest
+        go:
+          - '1.16'
+          - '1.19'
+    runs-on: ${{ matrix.os }}
+    steps:
+      - name: setup Go
+        uses: actions/setup-go@v3
+        with:
+          go-version: ${{ matrix.go }}
+
+      - name: checkout
+        uses: actions/checkout@v3
+
+      - name: test
+        run: |
+          go test -race ./...
+
+  # Test only the latest Go version on macOS; we use the macOS builders for BSD
+  # and illumos, and GitHub doesn't allow many of them to run concurrently. If
+  # it works on Windows and Linux with Go 1.16, then it probably does on macOS
+  # too.
+  testMacOS:
+    name: test
+    strategy:
+      fail-fast: false
+      matrix:
+        os:
+          - macos-11
+          - macos-12
+        go:
+          - '1.19'
+    runs-on: ${{ matrix.os }}
+    steps:
+      - name: setup Go
+        uses: actions/setup-go@v3
+        with:
+          go-version: ${{ matrix.go }}
+
+      - name: checkout
+        uses: actions/checkout@v3
+
+      - name: test
+        run: |
+          go test -race ./...
+
+  # FreeBSD
+  testFreeBSD:
+    runs-on: macos-12
+    name: test (freebsd, 1.18)
+    steps:
+      - uses: actions/checkout@v3
+      - name: test (freebsd, 1.18)
+        id: test
+        uses: vmactions/freebsd-vm@v0.2.0
+        with:
+          usesh: true
+          prepare: pkg install -y go
+          run: |
+            pw user add -n action -m
+            su action -c 'go test -race ./...'
+
+  # OpenBSD; no -race as the VM doesn't include the comp set.
+  #
+  # TODO: should probably add this, but on my local machine the tests time out
+  #       with -race as the waits aren't long enough (OpenBSD is kind of slow),
+  #       so should probably look into that first. Go 1.19 is supposed to have a
+  #       much faster race detector, so maybe waiting until we have that is
+  #       enough.
+  testOpenBSD:
+    runs-on: macos-12
+    name: test (openbsd, 1.17)
+    steps:
+      - uses: actions/checkout@v3
+      - name: test (openbsd, 1.17)
+        id: test
+        uses: vmactions/openbsd-vm@v0.0.6
+        with:
+          prepare: pkg_add go
+          run: |
+            useradd -mG wheel action
+            su action -c 'go test ./...'
+
+  # NetBSD
+  testNetBSD:
+    runs-on: macos-12
+    name: test (netbsd, 1.18)
+    steps:
+      - uses: actions/checkout@v3
+      - name: test (netbsd, 1.18)
+        id: test
+        uses: vmactions/netbsd-vm@v0.0.4
+        with:
+          prepare: pkg_add go
+          # TODO: no -race for the same reason as OpenBSD (the timing; it does run).
+          run: |
+            useradd -mG wheel action
+            su action -c 'go118 test ./...'
+
+  # illumos
+  testillumos:
+    runs-on: macos-12
+    name: test (illumos, 1.17)
+    steps:
+    - uses: actions/checkout@v2
+    - name: test (illumos, 1.17)
+      id: test
+      uses: papertigers/illumos-vm@r38
+      with:
+        prepare: |
+          pkg install go-117
+        run: |
+          /opt/ooce/go-1.17/bin/go test ./...
+
+  # Older Debian 6, for old Linux kernels.
+  testDebian6:
+    runs-on: macos-12
+    name: test (debian6, 1.19)
+    strategy:
+      fail-fast: false
+    steps:
+      - uses: actions/checkout@v3
+
+      - name: Cache Vagrant boxes
+        uses: actions/cache@v3
+        with:
+          path: ~/.vagrant.d/boxes
+          key: ${{ runner.os }}-vagrant-${{ hashFiles('Vagrantfile') }}
+          restore-keys: |
+            ${{ runner.os }}-vagrant-
+
+      - name: setup Go
+        uses: actions/setup-go@v3
+        with:
+          go-version: '1.19'
+
+      - name: test (debian6, 1.19)
+        id: test
+        run: |
+          cp -f .github/workflows/Vagrantfile.debian6 Vagrantfile
+          export GOOS=linux
+          export GOARCH=amd64
+          for p in $(go list ./...); do
+            go test -c -o ${p//\//-}.test $p
+          done
+          vagrant up
+          for t in *.test; do
+            vagrant ssh -c "/vagrant/$t"
+          done
diff --git a/go_package_port/github.com/fsnotify/fsnotify/.gitignore b/go_package_port/github.com/fsnotify/fsnotify/.gitignore
new file mode 100644
index 0000000..1d89d85
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/.gitignore
@@ -0,0 +1,6 @@
+# go test -c output
+*.test
+*.test.exe
+
+# Output of go build ./cmd/fsnotify
+/fsnotify
diff --git a/go_package_port/github.com/fsnotify/fsnotify/.mailmap b/go_package_port/github.com/fsnotify/fsnotify/.mailmap
new file mode 100644
index 0000000..a04f290
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/.mailmap
@@ -0,0 +1,2 @@
+Chris Howey <howeyc@gmail.com> <chris@howey.me>
+Nathan Youngman <git@nathany.com> <4566+nathany@users.noreply.github.com>
diff --git a/go_package_port/github.com/fsnotify/fsnotify/CHANGELOG.md b/go_package_port/github.com/fsnotify/fsnotify/CHANGELOG.md
new file mode 100644
index 0000000..77f9593
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/CHANGELOG.md
@@ -0,0 +1,470 @@
+# Changelog
+
+All notable changes to this project will be documented in this file.
+
+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
+and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
+
+## [Unreleased]
+
+Nothing yet.
+
+## [1.6.0] - 2022-10-13
+
+This version of fsnotify needs Go 1.16 (this was already the case since 1.5.1,
+but not documented). It also increases the minimum Linux version to 2.6.32.
+
+### Additions
+
+- all: add `Event.Has()` and `Op.Has()` ([#477])
+
+  This makes checking events a lot easier; for example:
+
+	    if event.Op&Write == Write && !(event.Op&Remove == Remove) {
+	    }
+
+	Becomes:
+
+	    if event.Has(Write) && !event.Has(Remove) {
+	    }
+
+- all: add cmd/fsnotify ([#463])
+
+  A command-line utility for testing and some examples.
+
+### Changes and fixes
+
+- inotify: don't ignore events for files that don't exist ([#260], [#470])
+
+  Previously the inotify watcher would call `os.Lstat()` to check if a file
+  still exists before emitting events.
+
+  This was inconsistent with other platforms and resulted in inconsistent event
+  reporting (e.g. when a file is quickly removed and re-created), and generally
+  a source of confusion. It was added in 2013 to fix a memory leak that no
+  longer exists.
+
+- all: return `ErrNonExistentWatch` when `Remove()` is called on a path that's
+  not watched ([#460])
+
+- inotify: replace epoll() with non-blocking inotify ([#434])
+
+  Non-blocking inotify was not generally available at the time this library was
+  written in 2014, but now it is. As a result, the minimum Linux version is
+  bumped from 2.6.27 to 2.6.32. This hugely simplifies the code and is faster.
+
+- kqueue: don't check for events every 100ms ([#480])
+
+  The watcher would wake up every 100ms, even when there was nothing to do. Now
+  it waits until there is something to do.
+
+- macos: retry opening files on EINTR ([#475])
+
+- kqueue: skip unreadable files ([#479])
+
+  kqueue requires a file descriptor for every file in a directory; this would
+  fail if a file was unreadable by the current user. Now these files are simply
+  skipped.
+
+- windows: fix renaming a watched directory if the parent is also watched ([#370])
+
+- windows: increase buffer size from 4K to 64K ([#485])
+
+- windows: close file handle on Remove() ([#288])
+
+- kqueue: put pathname in the error if watching a file fails ([#471])
+
+- inotify, windows: calling Close() more than once could race ([#465])
+
+- kqueue: improve Close() performance ([#233])
+
+- all: various documentation additions and clarifications.
+
+[#233]: https://github.com/fsnotify/fsnotify/pull/233
+[#260]: https://github.com/fsnotify/fsnotify/pull/260
+[#288]: https://github.com/fsnotify/fsnotify/pull/288
+[#370]: https://github.com/fsnotify/fsnotify/pull/370
+[#434]: https://github.com/fsnotify/fsnotify/pull/434
+[#460]: https://github.com/fsnotify/fsnotify/pull/460
+[#463]: https://github.com/fsnotify/fsnotify/pull/463
+[#465]: https://github.com/fsnotify/fsnotify/pull/465
+[#470]: https://github.com/fsnotify/fsnotify/pull/470
+[#471]: https://github.com/fsnotify/fsnotify/pull/471
+[#475]: https://github.com/fsnotify/fsnotify/pull/475
+[#477]: https://github.com/fsnotify/fsnotify/pull/477
+[#479]: https://github.com/fsnotify/fsnotify/pull/479
+[#480]: https://github.com/fsnotify/fsnotify/pull/480
+[#485]: https://github.com/fsnotify/fsnotify/pull/485
+
+## [1.5.4] - 2022-04-25
+
+* Windows: add missing defer to `Watcher.WatchList` [#447](https://github.com/fsnotify/fsnotify/pull/447)
+* go.mod: use latest x/sys [#444](https://github.com/fsnotify/fsnotify/pull/444)
+* Fix compilation for OpenBSD [#443](https://github.com/fsnotify/fsnotify/pull/443)
+
+## [1.5.3] - 2022-04-22
+
+* This version is retracted. An incorrect branch is published accidentally [#445](https://github.com/fsnotify/fsnotify/issues/445)
+
+## [1.5.2] - 2022-04-21
+
+* Add a feature to return the directories and files that are being monitored [#374](https://github.com/fsnotify/fsnotify/pull/374)
+* Fix potential crash on windows if `raw.FileNameLength` exceeds `syscall.MAX_PATH` [#361](https://github.com/fsnotify/fsnotify/pull/361)
+* Allow build on unsupported GOOS [#424](https://github.com/fsnotify/fsnotify/pull/424)
+* Don't set `poller.fd` twice in `newFdPoller` [#406](https://github.com/fsnotify/fsnotify/pull/406)
+* fix go vet warnings: call to `(*T).Fatalf` from a non-test goroutine [#416](https://github.com/fsnotify/fsnotify/pull/416)
+
+## [1.5.1] - 2021-08-24
+
+* Revert Add AddRaw to not follow symlinks [#394](https://github.com/fsnotify/fsnotify/pull/394)
+
+## [1.5.0] - 2021-08-20
+
+* Go: Increase minimum required version to Go 1.12 [#381](https://github.com/fsnotify/fsnotify/pull/381)
+* Feature: Add AddRaw method which does not follow symlinks when adding a watch [#289](https://github.com/fsnotify/fsnotify/pull/298)
+* Windows: Follow symlinks by default like on all other systems [#289](https://github.com/fsnotify/fsnotify/pull/289)
+* CI: Use GitHub Actions for CI and cover go 1.12-1.17
+   [#378](https://github.com/fsnotify/fsnotify/pull/378)
+   [#381](https://github.com/fsnotify/fsnotify/pull/381)
+   [#385](https://github.com/fsnotify/fsnotify/pull/385)
+* Go 1.14+: Fix unsafe pointer conversion [#325](https://github.com/fsnotify/fsnotify/pull/325)
+
+## [1.4.9] - 2020-03-11
+
+* Move example usage to the readme #329. This may resolve #328.
+
+## [1.4.8] - 2020-03-10
+
+* CI: test more go versions (@nathany 1d13583d846ea9d66dcabbfefbfb9d8e6fb05216)
+* Tests: Queued inotify events could have been read by the test before max_queued_events was hit (@matthias-stone #265)
+* Tests:  t.Fatalf -> t.Errorf in go routines (@gdey #266)
+* CI: Less verbosity (@nathany #267)
+* Tests: Darwin: Exchangedata is deprecated on 10.13 (@nathany #267)
+* Tests: Check if channels are closed in the example (@alexeykazakov #244)
+* CI: Only run golint on latest version of go and fix issues (@cpuguy83 #284)
+* CI: Add windows to travis matrix (@cpuguy83 #284)
+* Docs: Remover appveyor badge (@nathany 11844c0959f6fff69ba325d097fce35bd85a8e93)
+* Linux: create epoll and pipe fds with close-on-exec (@JohannesEbke #219)
+* Linux: open files with close-on-exec (@linxiulei #273)
+* Docs: Plan to support fanotify (@nathany ab058b44498e8b7566a799372a39d150d9ea0119 )
+* Project: Add go.mod (@nathany #309)
+* Project: Revise editor config (@nathany #309)
+* Project: Update copyright for 2019 (@nathany #309)
+* CI: Drop go1.8 from CI matrix (@nathany #309)
+* Docs: Updating the FAQ section for supportability with NFS & FUSE filesystems (@Pratik32 4bf2d1fec78374803a39307bfb8d340688f4f28e )
+
+## [1.4.7] - 2018-01-09
+
+* BSD/macOS: Fix possible deadlock on closing the watcher on kqueue (thanks @nhooyr and @glycerine)
+* Tests: Fix missing verb on format string (thanks @rchiossi)
+* Linux: Fix deadlock in Remove (thanks @aarondl)
+* Linux: Watch.Add improvements (avoid race, fix consistency, reduce garbage) (thanks @twpayne)
+* Docs: Moved FAQ into the README (thanks @vahe)
+* Linux: Properly handle inotify's IN_Q_OVERFLOW event (thanks @zeldovich)
+* Docs: replace references to OS X with macOS
+
+## [1.4.2] - 2016-10-10
+
+* Linux: use InotifyInit1 with IN_CLOEXEC to stop leaking a file descriptor to a child process when using fork/exec [#178](https://github.com/fsnotify/fsnotify/pull/178) (thanks @pattyshack)
+
+## [1.4.1] - 2016-10-04
+
+* Fix flaky inotify stress test on Linux [#177](https://github.com/fsnotify/fsnotify/pull/177) (thanks @pattyshack)
+
+## [1.4.0] - 2016-10-01
+
+* add a String() method to Event.Op [#165](https://github.com/fsnotify/fsnotify/pull/165) (thanks @oozie)
+
+## [1.3.1] - 2016-06-28
+
+* Windows: fix for double backslash when watching the root of a drive [#151](https://github.com/fsnotify/fsnotify/issues/151) (thanks @brunoqc)
+
+## [1.3.0] - 2016-04-19
+
+* Support linux/arm64 by [patching](https://go-review.googlesource.com/#/c/21971/) x/sys/unix and switching to to it from syscall (thanks @suihkulokki) [#135](https://github.com/fsnotify/fsnotify/pull/135)
+
+## [1.2.10] - 2016-03-02
+
+* Fix golint errors in windows.go [#121](https://github.com/fsnotify/fsnotify/pull/121) (thanks @tiffanyfj)
+
+## [1.2.9] - 2016-01-13
+
+kqueue: Fix logic for CREATE after REMOVE [#111](https://github.com/fsnotify/fsnotify/pull/111) (thanks @bep)
+
+## [1.2.8] - 2015-12-17
+
+* kqueue: fix race condition in Close [#105](https://github.com/fsnotify/fsnotify/pull/105) (thanks @djui for reporting the issue and @ppknap for writing a failing test)
+* inotify: fix race in test
+* enable race detection for continuous integration (Linux, Mac, Windows)
+
+## [1.2.5] - 2015-10-17
+
+* inotify: use epoll_create1 for arm64 support (requires Linux 2.6.27 or later) [#100](https://github.com/fsnotify/fsnotify/pull/100) (thanks @suihkulokki)
+* inotify: fix path leaks [#73](https://github.com/fsnotify/fsnotify/pull/73) (thanks @chamaken)
+* kqueue: watch for rename events on subdirectories [#83](https://github.com/fsnotify/fsnotify/pull/83) (thanks @guotie)
+* kqueue: avoid infinite loops from symlinks cycles [#101](https://github.com/fsnotify/fsnotify/pull/101) (thanks @illicitonion)
+
+## [1.2.1] - 2015-10-14
+
+* kqueue: don't watch named pipes [#98](https://github.com/fsnotify/fsnotify/pull/98) (thanks @evanphx)
+
+## [1.2.0] - 2015-02-08
+
+* inotify: use epoll to wake up readEvents [#66](https://github.com/fsnotify/fsnotify/pull/66) (thanks @PieterD)
+* inotify: closing watcher should now always shut down goroutine [#63](https://github.com/fsnotify/fsnotify/pull/63) (thanks @PieterD)
+* kqueue: close kqueue after removing watches, fixes [#59](https://github.com/fsnotify/fsnotify/issues/59)
+
+## [1.1.1] - 2015-02-05
+
+* inotify: Retry read on EINTR [#61](https://github.com/fsnotify/fsnotify/issues/61) (thanks @PieterD)
+
+## [1.1.0] - 2014-12-12
+
+* kqueue: rework internals [#43](https://github.com/fsnotify/fsnotify/pull/43)
+    * add low-level functions
+    * only need to store flags on directories
+    * less mutexes [#13](https://github.com/fsnotify/fsnotify/issues/13)
+    * done can be an unbuffered channel
+    * remove calls to os.NewSyscallError
+* More efficient string concatenation for Event.String() [#52](https://github.com/fsnotify/fsnotify/pull/52) (thanks @mdlayher)
+* kqueue: fix regression in  rework causing subdirectories to be watched [#48](https://github.com/fsnotify/fsnotify/issues/48)
+* kqueue: cleanup internal watch before sending remove event [#51](https://github.com/fsnotify/fsnotify/issues/51)
+
+## [1.0.4] - 2014-09-07
+
+* kqueue: add dragonfly to the build tags.
+* Rename source code files, rearrange code so exported APIs are at the top.
+* Add done channel to example code. [#37](https://github.com/fsnotify/fsnotify/pull/37) (thanks @chenyukang)
+
+## [1.0.3] - 2014-08-19
+
+* [Fix] Windows MOVED_TO now translates to Create like on BSD and Linux. [#36](https://github.com/fsnotify/fsnotify/issues/36)
+
+## [1.0.2] - 2014-08-17
+
+* [Fix] Missing create events on macOS. [#14](https://github.com/fsnotify/fsnotify/issues/14) (thanks @zhsso)
+* [Fix] Make ./path and path equivalent. (thanks @zhsso)
+
+## [1.0.0] - 2014-08-15
+
+* [API] Remove AddWatch on Windows, use Add.
+* Improve documentation for exported identifiers. [#30](https://github.com/fsnotify/fsnotify/issues/30)
+* Minor updates based on feedback from golint.
+
+## dev / 2014-07-09
+
+* Moved to [github.com/fsnotify/fsnotify](https://github.com/fsnotify/fsnotify).
+* Use os.NewSyscallError instead of returning errno (thanks @hariharan-uno)
+
+## dev / 2014-07-04
+
+* kqueue: fix incorrect mutex used in Close()
+* Update example to demonstrate usage of Op.
+
+## dev / 2014-06-28
+
+* [API] Don't set the Write Op for attribute notifications [#4](https://github.com/fsnotify/fsnotify/issues/4)
+* Fix for String() method on Event (thanks Alex Brainman)
+* Don't build on Plan 9 or Solaris (thanks @4ad)
+
+## dev / 2014-06-21
+
+* Events channel of type Event rather than *Event.
+* [internal] use syscall constants directly for inotify and kqueue.
+* [internal] kqueue: rename events to kevents and fileEvent to event.
+
+## dev / 2014-06-19
+
+* Go 1.3+ required on Windows (uses syscall.ERROR_MORE_DATA internally).
+* [internal] remove cookie from Event struct (unused).
+* [internal] Event struct has the same definition across every OS.
+* [internal] remove internal watch and removeWatch methods.
+
+## dev / 2014-06-12
+
+* [API] Renamed Watch() to Add() and RemoveWatch() to Remove().
+* [API] Pluralized channel names: Events and Errors.
+* [API] Renamed FileEvent struct to Event.
+* [API] Op constants replace methods like IsCreate().
+
+## dev / 2014-06-12
+
+* Fix data race on kevent buffer (thanks @tilaks) [#98](https://github.com/howeyc/fsnotify/pull/98)
+
+## dev / 2014-05-23
+
+* [API] Remove current implementation of WatchFlags.
+    * current implementation doesn't take advantage of OS for efficiency
+    * provides little benefit over filtering events as they are received, but has  extra bookkeeping and mutexes
+    * no tests for the current implementation
+    * not fully implemented on Windows [#93](https://github.com/howeyc/fsnotify/issues/93#issuecomment-39285195)
+
+## [0.9.3] - 2014-12-31
+
+* kqueue: cleanup internal watch before sending remove event [#51](https://github.com/fsnotify/fsnotify/issues/51)
+
+## [0.9.2] - 2014-08-17
+
+* [Backport] Fix missing create events on macOS. [#14](https://github.com/fsnotify/fsnotify/issues/14) (thanks @zhsso)
+
+## [0.9.1] - 2014-06-12
+
+* Fix data race on kevent buffer (thanks @tilaks) [#98](https://github.com/howeyc/fsnotify/pull/98)
+
+## [0.9.0] - 2014-01-17
+
+* IsAttrib() for events that only concern a file's metadata [#79][] (thanks @abustany)
+* [Fix] kqueue: fix deadlock [#77][] (thanks @cespare)
+* [NOTICE] Development has moved to `code.google.com/p/go.exp/fsnotify` in preparation for inclusion in the Go standard library.
+
+## [0.8.12] - 2013-11-13
+
+* [API] Remove FD_SET and friends from Linux adapter
+
+## [0.8.11] - 2013-11-02
+
+* [Doc] Add Changelog [#72][] (thanks @nathany)
+* [Doc] Spotlight and double modify events on macOS [#62][] (reported by @paulhammond)
+
+## [0.8.10] - 2013-10-19
+
+* [Fix] kqueue: remove file watches when parent directory is removed [#71][] (reported by @mdwhatcott)
+* [Fix] kqueue: race between Close and readEvents [#70][] (reported by @bernerdschaefer)
+* [Doc] specify OS-specific limits in README (thanks @debrando)
+
+## [0.8.9] - 2013-09-08
+
+* [Doc] Contributing (thanks @nathany)
+* [Doc] update package path in example code [#63][] (thanks @paulhammond)
+* [Doc] GoCI badge in README (Linux only) [#60][]
+* [Doc] Cross-platform testing with Vagrant  [#59][] (thanks @nathany)
+
+## [0.8.8] - 2013-06-17
+
+* [Fix] Windows: handle `ERROR_MORE_DATA` on Windows [#49][] (thanks @jbowtie)
+
+## [0.8.7] - 2013-06-03
+
+* [API] Make syscall flags internal
+* [Fix] inotify: ignore event changes
+* [Fix] race in symlink test [#45][] (reported by @srid)
+* [Fix] tests on Windows
+* lower case error messages
+
+## [0.8.6] - 2013-05-23
+
+* kqueue: Use EVT_ONLY flag on Darwin
+* [Doc] Update README with full example
+
+## [0.8.5] - 2013-05-09
+
+* [Fix] inotify: allow monitoring of "broken" symlinks (thanks @tsg)
+
+## [0.8.4] - 2013-04-07
+
+* [Fix] kqueue: watch all file events [#40][] (thanks @ChrisBuchholz)
+
+## [0.8.3] - 2013-03-13
+
+* [Fix] inoitfy/kqueue memory leak [#36][] (reported by @nbkolchin)
+* [Fix] kqueue: use fsnFlags for watching a directory [#33][] (reported by @nbkolchin)
+
+## [0.8.2] - 2013-02-07
+
+* [Doc] add Authors
+* [Fix] fix data races for map access [#29][] (thanks @fsouza)
+
+## [0.8.1] - 2013-01-09
+
+* [Fix] Windows path separators
+* [Doc] BSD License
+
+## [0.8.0] - 2012-11-09
+
+* kqueue: directory watching improvements (thanks @vmirage)
+* inotify: add `IN_MOVED_TO` [#25][] (requested by @cpisto)
+* [Fix] kqueue: deleting watched directory [#24][] (reported by @jakerr)
+
+## [0.7.4] - 2012-10-09
+
+* [Fix] inotify: fixes from https://codereview.appspot.com/5418045/ (ugorji)
+* [Fix] kqueue: preserve watch flags when watching for delete [#21][] (reported by @robfig)
+* [Fix] kqueue: watch the directory even if it isn't a new watch (thanks @robfig)
+* [Fix] kqueue: modify after recreation of file
+
+## [0.7.3] - 2012-09-27
+
+* [Fix] kqueue: watch with an existing folder inside the watched folder (thanks @vmirage)
+* [Fix] kqueue: no longer get duplicate CREATE events
+
+## [0.7.2] - 2012-09-01
+
+* kqueue: events for created directories
+
+## [0.7.1] - 2012-07-14
+
+* [Fix] for renaming files
+
+## [0.7.0] - 2012-07-02
+
+* [Feature] FSNotify flags
+* [Fix] inotify: Added file name back to event path
+
+## [0.6.0] - 2012-06-06
+
+* kqueue: watch files after directory created (thanks @tmc)
+
+## [0.5.1] - 2012-05-22
+
+* [Fix] inotify: remove all watches before Close()
+
+## [0.5.0] - 2012-05-03
+
+* [API] kqueue: return errors during watch instead of sending over channel
+* kqueue: match symlink behavior on Linux
+* inotify: add `DELETE_SELF` (requested by @taralx)
+* [Fix] kqueue: handle EINTR (reported by @robfig)
+* [Doc] Godoc example [#1][] (thanks @davecheney)
+
+## [0.4.0] - 2012-03-30
+
+* Go 1 released: build with go tool
+* [Feature] Windows support using winfsnotify
+* Windows does not have attribute change notifications
+* Roll attribute notifications into IsModify
+
+## [0.3.0] - 2012-02-19
+
+* kqueue: add files when watch directory
+
+## [0.2.0] - 2011-12-30
+
+* update to latest Go weekly code
+
+## [0.1.0] - 2011-10-19
+
+* kqueue: add watch on file creation to match inotify
+* kqueue: create file event
+* inotify: ignore `IN_IGNORED` events
+* event String()
+* linux: common FileEvent functions
+* initial commit
+
+[#79]: https://github.com/howeyc/fsnotify/pull/79
+[#77]: https://github.com/howeyc/fsnotify/pull/77
+[#72]: https://github.com/howeyc/fsnotify/issues/72
+[#71]: https://github.com/howeyc/fsnotify/issues/71
+[#70]: https://github.com/howeyc/fsnotify/issues/70
+[#63]: https://github.com/howeyc/fsnotify/issues/63
+[#62]: https://github.com/howeyc/fsnotify/issues/62
+[#60]: https://github.com/howeyc/fsnotify/issues/60
+[#59]: https://github.com/howeyc/fsnotify/issues/59
+[#49]: https://github.com/howeyc/fsnotify/issues/49
+[#45]: https://github.com/howeyc/fsnotify/issues/45
+[#40]: https://github.com/howeyc/fsnotify/issues/40
+[#36]: https://github.com/howeyc/fsnotify/issues/36
+[#33]: https://github.com/howeyc/fsnotify/issues/33
+[#29]: https://github.com/howeyc/fsnotify/issues/29
+[#25]: https://github.com/howeyc/fsnotify/issues/25
+[#24]: https://github.com/howeyc/fsnotify/issues/24
+[#21]: https://github.com/howeyc/fsnotify/issues/21
diff --git a/go_package_port/github.com/fsnotify/fsnotify/CONTRIBUTING.md b/go_package_port/github.com/fsnotify/fsnotify/CONTRIBUTING.md
new file mode 100644
index 0000000..ea37975
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/CONTRIBUTING.md
@@ -0,0 +1,26 @@
+Thank you for your interest in contributing to fsnotify! We try to review and
+merge PRs in a reasonable timeframe, but please be aware that:
+
+- To avoid "wasted" work, please discus changes on the issue tracker first. You
+  can just send PRs, but they may end up being rejected for one reason or the
+  other.
+
+- fsnotify is a cross-platform library, and changes must work reasonably well on
+  all supported platforms.
+
+- Changes will need to be compatible; old code should still compile, and the
+  runtime behaviour can't change in ways that are likely to lead to problems for
+  users.
+
+Testing
+-------
+Just `go test ./...` runs all the tests; the CI runs this on all supported
+platforms. Testing different platforms locally can be done with something like
+[goon] or [Vagrant], but this isn't super-easy to set up at the moment.
+
+Use the `-short` flag to make the "stress test" run faster.
+
+
+[goon]: https://github.com/arp242/goon
+[Vagrant]: https://www.vagrantup.com/
+[integration_test.go]: /integration_test.go
diff --git a/go_package_port/github.com/fsnotify/fsnotify/LICENSE b/go_package_port/github.com/fsnotify/fsnotify/LICENSE
new file mode 100644
index 0000000..fb03ade
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/LICENSE
@@ -0,0 +1,25 @@
+Copyright © 2012 The Go Authors. All rights reserved.
+Copyright © fsnotify Authors. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice, this
+  list of conditions and the following disclaimer in the documentation and/or
+  other materials provided with the distribution.
+* Neither the name of Google Inc. nor the names of its contributors may be used
+  to endorse or promote products derived from this software without specific
+  prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/go_package_port/github.com/fsnotify/fsnotify/README.md b/go_package_port/github.com/fsnotify/fsnotify/README.md
new file mode 100644
index 0000000..d4e6080
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/README.md
@@ -0,0 +1,161 @@
+fsnotify is a Go library to provide cross-platform filesystem notifications on
+Windows, Linux, macOS, and BSD systems.
+
+Go 1.16 or newer is required; the full documentation is at
+https://pkg.go.dev/github.com/fsnotify/fsnotify
+
+**It's best to read the documentation at pkg.go.dev, as it's pinned to the last
+released version, whereas this README is for the last development version which
+may include additions/changes.**
+
+---
+
+Platform support:
+
+| Adapter               | OS             | Status                                                       |
+| --------------------- | ---------------| -------------------------------------------------------------|
+| inotify               | Linux 2.6.32+  | Supported                                                    |
+| kqueue                | BSD, macOS     | Supported                                                    |
+| ReadDirectoryChangesW | Windows        | Supported                                                    |
+| FSEvents              | macOS          | [Planned](https://github.com/fsnotify/fsnotify/issues/11)    |
+| FEN                   | Solaris 11     | [In Progress](https://github.com/fsnotify/fsnotify/pull/371) |
+| fanotify              | Linux 5.9+     | [Maybe](https://github.com/fsnotify/fsnotify/issues/114)     |
+| USN Journals          | Windows        | [Maybe](https://github.com/fsnotify/fsnotify/issues/53)      |
+| Polling               | *All*          | [Maybe](https://github.com/fsnotify/fsnotify/issues/9)       |
+
+Linux and macOS should include Android and iOS, but these are currently untested.
+
+Usage
+-----
+A basic example:
+
+```go
+package main
+
+import (
+    "log"
+
+    "github.com/fsnotify/fsnotify"
+)
+
+func main() {
+    // Create new watcher.
+    watcher, err := fsnotify.NewWatcher()
+    if err != nil {
+        log.Fatal(err)
+    }
+    defer watcher.Close()
+
+    // Start listening for events.
+    go func() {
+        for {
+            select {
+            case event, ok := <-watcher.Events:
+                if !ok {
+                    return
+                }
+                log.Println("event:", event)
+                if event.Has(fsnotify.Write) {
+                    log.Println("modified file:", event.Name)
+                }
+            case err, ok := <-watcher.Errors:
+                if !ok {
+                    return
+                }
+                log.Println("error:", err)
+            }
+        }
+    }()
+
+    // Add a path.
+    err = watcher.Add("/tmp")
+    if err != nil {
+        log.Fatal(err)
+    }
+
+    // Block main goroutine forever.
+    <-make(chan struct{})
+}
+```
+
+Some more examples can be found in [cmd/fsnotify](cmd/fsnotify), which can be
+run with:
+
+    % go run ./cmd/fsnotify
+
+FAQ
+---
+### Will a file still be watched when it's moved to another directory?
+No, not unless you are watching the location it was moved to.
+
+### Are subdirectories watched too?
+No, you must add watches for any directory you want to watch (a recursive
+watcher is on the roadmap: [#18]).
+
+[#18]: https://github.com/fsnotify/fsnotify/issues/18
+
+### Do I have to watch the Error and Event channels in a goroutine?
+As of now, yes (you can read both channels in the same goroutine using `select`,
+you don't need a separate goroutine for both channels; see the example).
+
+### Why don't notifications work with NFS, SMB, FUSE, /proc, or /sys?
+fsnotify requires support from underlying OS to work. The current NFS and SMB
+protocols does not provide network level support for file notifications, and
+neither do the /proc and /sys virtual filesystems.
+
+This could be fixed with a polling watcher ([#9]), but it's not yet implemented.
+
+[#9]: https://github.com/fsnotify/fsnotify/issues/9
+
+Platform-specific notes
+-----------------------
+### Linux
+When a file is removed a REMOVE event won't be emitted until all file
+descriptors are closed; it will emit a CHMOD instead:
+
+    fp := os.Open("file")
+    os.Remove("file")        // CHMOD
+    fp.Close()               // REMOVE
+
+This is the event that inotify sends, so not much can be changed about this.
+
+The `fs.inotify.max_user_watches` sysctl variable specifies the upper limit for
+the number of watches per user, and `fs.inotify.max_user_instances` specifies
+the maximum number of inotify instances per user. Every Watcher you create is an
+"instance", and every path you add is a "watch".
+
+These are also exposed in `/proc` as `/proc/sys/fs/inotify/max_user_watches` and
+`/proc/sys/fs/inotify/max_user_instances`
+
+To increase them you can use `sysctl` or write the value to proc file:
+
+    # The default values on Linux 5.18
+    sysctl fs.inotify.max_user_watches=124983
+    sysctl fs.inotify.max_user_instances=128
+
+To make the changes persist on reboot edit `/etc/sysctl.conf` or
+`/usr/lib/sysctl.d/50-default.conf` (details differ per Linux distro; check your
+distro's documentation):
+
+    fs.inotify.max_user_watches=124983
+    fs.inotify.max_user_instances=128
+
+Reaching the limit will result in a "no space left on device" or "too many open
+files" error.
+
+### kqueue (macOS, all BSD systems)
+kqueue requires opening a file descriptor for every file that's being watched;
+so if you're watching a directory with five files then that's six file
+descriptors. You will run in to your system's "max open files" limit faster on
+these platforms.
+
+The sysctl variables `kern.maxfiles` and `kern.maxfilesperproc` can be used to
+control the maximum number of open files.
+
+### macOS
+Spotlight indexing on macOS can result in multiple events (see [#15]). A temporary
+workaround is to add your folder(s) to the *Spotlight Privacy settings* until we
+have a native FSEvents implementation (see [#11]).
+
+[#11]: https://github.com/fsnotify/fsnotify/issues/11
+[#15]: https://github.com/fsnotify/fsnotify/issues/15
diff --git a/go_package_port/github.com/fsnotify/fsnotify/backend_fen.go b/go_package_port/github.com/fsnotify/fsnotify/backend_fen.go
new file mode 100644
index 0000000..1a95ad8
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/backend_fen.go
@@ -0,0 +1,162 @@
+//go:build solaris
+// +build solaris
+
+package fsnotify
+
+import (
+	"errors"
+)
+
+// Watcher watches a set of paths, delivering events on a channel.
+//
+// A watcher should not be copied (e.g. pass it by pointer, rather than by
+// value).
+//
+// # Linux notes
+//
+// When a file is removed a Remove event won't be emitted until all file
+// descriptors are closed, and deletes will always emit a Chmod. For example:
+//
+//     fp := os.Open("file")
+//     os.Remove("file")        // Triggers Chmod
+//     fp.Close()               // Triggers Remove
+//
+// This is the event that inotify sends, so not much can be changed about this.
+//
+// The fs.inotify.max_user_watches sysctl variable specifies the upper limit
+// for the number of watches per user, and fs.inotify.max_user_instances
+// specifies the maximum number of inotify instances per user. Every Watcher you
+// create is an "instance", and every path you add is a "watch".
+//
+// These are also exposed in /proc as /proc/sys/fs/inotify/max_user_watches and
+// /proc/sys/fs/inotify/max_user_instances
+//
+// To increase them you can use sysctl or write the value to the /proc file:
+//
+//     # Default values on Linux 5.18
+//     sysctl fs.inotify.max_user_watches=124983
+//     sysctl fs.inotify.max_user_instances=128
+//
+// To make the changes persist on reboot edit /etc/sysctl.conf or
+// /usr/lib/sysctl.d/50-default.conf (details differ per Linux distro; check
+// your distro's documentation):
+//
+//     fs.inotify.max_user_watches=124983
+//     fs.inotify.max_user_instances=128
+//
+// Reaching the limit will result in a "no space left on device" or "too many open
+// files" error.
+//
+// # kqueue notes (macOS, BSD)
+//
+// kqueue requires opening a file descriptor for every file that's being watched;
+// so if you're watching a directory with five files then that's six file
+// descriptors. You will run in to your system's "max open files" limit faster on
+// these platforms.
+//
+// The sysctl variables kern.maxfiles and kern.maxfilesperproc can be used to
+// control the maximum number of open files, as well as /etc/login.conf on BSD
+// systems.
+//
+// # macOS notes
+//
+// Spotlight indexing on macOS can result in multiple events (see [#15]). A
+// temporary workaround is to add your folder(s) to the "Spotlight Privacy
+// Settings" until we have a native FSEvents implementation (see [#11]).
+//
+// [#11]: https://github.com/fsnotify/fsnotify/issues/11
+// [#15]: https://github.com/fsnotify/fsnotify/issues/15
+type Watcher struct {
+	// Events sends the filesystem change events.
+	//
+	// fsnotify can send the following events; a "path" here can refer to a
+	// file, directory, symbolic link, or special file like a FIFO.
+	//
+	//   fsnotify.Create    A new path was created; this may be followed by one
+	//                      or more Write events if data also gets written to a
+	//                      file.
+	//
+	//   fsnotify.Remove    A path was removed.
+	//
+	//   fsnotify.Rename    A path was renamed. A rename is always sent with the
+	//                      old path as Event.Name, and a Create event will be
+	//                      sent with the new name. Renames are only sent for
+	//                      paths that are currently watched; e.g. moving an
+	//                      unmonitored file into a monitored directory will
+	//                      show up as just a Create. Similarly, renaming a file
+	//                      to outside a monitored directory will show up as
+	//                      only a Rename.
+	//
+	//   fsnotify.Write     A file or named pipe was written to. A Truncate will
+	//                      also trigger a Write. A single "write action"
+	//                      initiated by the user may show up as one or multiple
+	//                      writes, depending on when the system syncs things to
+	//                      disk. For example when compiling a large Go program
+	//                      you may get hundreds of Write events, so you
+	//                      probably want to wait until you've stopped receiving
+	//                      them (see the dedup example in cmd/fsnotify).
+	//
+	//   fsnotify.Chmod     Attributes were changed. On Linux this is also sent
+	//                      when a file is removed (or more accurately, when a
+	//                      link to an inode is removed). On kqueue it's sent
+	//                      and on kqueue when a file is truncated. On Windows
+	//                      it's never sent.
+	Events chan Event
+
+	// Errors sends any errors.
+	Errors chan error
+}
+
+// NewWatcher creates a new Watcher.
+func NewWatcher() (*Watcher, error) {
+	return nil, errors.New("FEN based watcher not yet supported for fsnotify\n")
+}
+
+// Close removes all watches and closes the events channel.
+func (w *Watcher) Close() error {
+	return nil
+}
+
+// Add starts monitoring the path for changes.
+//
+// A path can only be watched once; attempting to watch it more than once will
+// return an error. Paths that do not yet exist on the filesystem cannot be
+// added. A watch will be automatically removed if the path is deleted.
+//
+// A path will remain watched if it gets renamed to somewhere else on the same
+// filesystem, but the monitor will get removed if the path gets deleted and
+// re-created, or if it's moved to a different filesystem.
+//
+// Notifications on network filesystems (NFS, SMB, FUSE, etc.) or special
+// filesystems (/proc, /sys, etc.) generally don't work.
+//
+// # Watching directories
+//
+// All files in a directory are monitored, including new files that are created
+// after the watcher is started. Subdirectories are not watched (i.e. it's
+// non-recursive).
+//
+// # Watching files
+//
+// Watching individual files (rather than directories) is generally not
+// recommended as many tools update files atomically. Instead of "just" writing
+// to the file a temporary file will be written to first, and if successful the
+// temporary file is moved to to destination removing the original, or some
+// variant thereof. The watcher on the original file is now lost, as it no
+// longer exists.
+//
+// Instead, watch the parent directory and use Event.Name to filter out files
+// you're not interested in. There is an example of this in [cmd/fsnotify/file.go].
+func (w *Watcher) Add(name string) error {
+	return nil
+}
+
+// Remove stops monitoring the path for changes.
+//
+// Directories are always removed non-recursively. For example, if you added
+// /tmp/dir and /tmp/dir/subdir then you will need to remove both.
+//
+// Removing a path that has not yet been added returns [ErrNonExistentWatch].
+func (w *Watcher) Remove(name string) error {
+	return nil
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/backend_inotify.go b/go_package_port/github.com/fsnotify/fsnotify/backend_inotify.go
new file mode 100644
index 0000000..2991597
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/backend_inotify.go
@@ -0,0 +1,283 @@
+//go:build zos
+
+// Tags altered by Wharf (added zos)
+//
+package fsnotify
+
+import (
+	"errors"
+	"fmt"
+	"io"
+	"os"
+	"path/filepath"
+	"strings"
+	"sync"
+	"unsafe"
+
+	"golang.org/x/sys/unix"
+)
+
+type Watcher struct {
+	Events chan Event
+
+	Errors chan error
+
+	fd          int
+	mu          sync.Mutex
+	inotifyFile *os.File
+	watches     map[string]*watch
+	paths       map[int]string
+	done        chan struct{}
+	doneResp    chan struct{}
+}
+
+func NewWatcher() (*Watcher, error) {
+
+	fd, errno := unix.InotifyInit1(unix.IN_CLOEXEC | unix.IN_NONBLOCK)
+	if fd == -1 {
+		return nil, errno
+	}
+
+	w := &Watcher{
+		fd:          fd,
+		inotifyFile: os.NewFile(uintptr(fd), ""),
+		watches:     make(map[string]*watch),
+		paths:       make(map[int]string),
+		Events:      make(chan Event),
+		Errors:      make(chan error),
+		done:        make(chan struct{}),
+		doneResp:    make(chan struct{}),
+	}
+
+	go w.readEvents()
+	return w, nil
+}
+
+func (w *Watcher) sendEvent(e Event) bool {
+	select {
+	case w.Events <- e:
+		return true
+	case <-w.done:
+	}
+	return false
+}
+
+func (w *Watcher) sendError(err error) bool {
+	select {
+	case w.Errors <- err:
+		return true
+	case <-w.done:
+		return false
+	}
+}
+
+func (w *Watcher) isClosed() bool {
+	select {
+	case <-w.done:
+		return true
+	default:
+		return false
+	}
+}
+
+func (w *Watcher) Close() error {
+	w.mu.Lock()
+	if w.isClosed() {
+		w.mu.Unlock()
+		return nil
+	}
+
+	close(w.done)
+	w.mu.Unlock()
+
+	err := w.inotifyFile.Close()
+	if err != nil {
+		return err
+	}
+
+	<-w.doneResp
+
+	return nil
+}
+
+func (w *Watcher) Add(name string) error {
+	name = filepath.Clean(name)
+	if w.isClosed() {
+		return errors.New("inotify instance already closed")
+	}
+
+	var flags uint32 = unix.IN_MOVED_TO | unix.IN_MOVED_FROM |
+		unix.IN_CREATE | unix.IN_ATTRIB | unix.IN_MODIFY |
+		unix.IN_MOVE_SELF | unix.IN_DELETE | unix.IN_DELETE_SELF
+
+	w.mu.Lock()
+	defer w.mu.Unlock()
+	watchEntry := w.watches[name]
+	if watchEntry != nil {
+		flags |= watchEntry.flags | unix.IN_MASK_ADD
+	}
+	wd, errno := unix.InotifyAddWatch(w.fd, name, flags)
+	if wd == -1 {
+		return errno
+	}
+
+	if watchEntry == nil {
+		w.watches[name] = &watch{wd: uint32(wd), flags: flags}
+		w.paths[wd] = name
+	} else {
+		watchEntry.wd = uint32(wd)
+		watchEntry.flags = flags
+	}
+
+	return nil
+}
+
+func (w *Watcher) Remove(name string) error {
+	name = filepath.Clean(name)
+
+	w.mu.Lock()
+	defer w.mu.Unlock()
+	watch, ok := w.watches[name]
+
+	if !ok {
+		return fmt.Errorf("%w: %s", ErrNonExistentWatch, name)
+	}
+
+	delete(w.paths, int(watch.wd))
+	delete(w.watches, name)
+
+	success, errno := unix.InotifyRmWatch(w.fd, watch.wd)
+	if success == -1 {
+
+		return errno
+	}
+
+	return nil
+}
+
+func (w *Watcher) WatchList() []string {
+	w.mu.Lock()
+	defer w.mu.Unlock()
+
+	entries := make([]string, 0, len(w.watches))
+	for pathname := range w.watches {
+		entries = append(entries, pathname)
+	}
+
+	return entries
+}
+
+type watch struct {
+	wd    uint32
+	flags uint32
+}
+
+func (w *Watcher) readEvents() {
+	defer func() {
+		close(w.doneResp)
+		close(w.Errors)
+		close(w.Events)
+	}()
+
+	var (
+		buf   [unix.SizeofInotifyEvent * 4096]byte
+		errno error
+	)
+	for {
+
+		if w.isClosed() {
+			return
+		}
+
+		n, err := w.inotifyFile.Read(buf[:])
+		switch {
+		case errors.Unwrap(err) == os.ErrClosed:
+			return
+		case err != nil:
+			if !w.sendError(err) {
+				return
+			}
+			continue
+		}
+
+		if n < unix.SizeofInotifyEvent {
+			var err error
+			if n == 0 {
+
+				err = io.EOF
+			} else if n < 0 {
+
+				err = errno
+			} else {
+
+				err = errors.New("notify: short read in readEvents()")
+			}
+			if !w.sendError(err) {
+				return
+			}
+			continue
+		}
+
+		var offset uint32
+
+		for offset <= uint32(n-unix.SizeofInotifyEvent) {
+			var (
+				raw     = (*unix.InotifyEvent)(unsafe.Pointer(&buf[offset]))
+				mask    = uint32(raw.Mask)
+				nameLen = uint32(raw.Len)
+			)
+
+			if mask&unix.IN_Q_OVERFLOW != 0 {
+				if !w.sendError(ErrEventOverflow) {
+					return
+				}
+			}
+
+			w.mu.Lock()
+			name, ok := w.paths[int(raw.Wd)]
+
+			if ok && mask&unix.IN_DELETE_SELF == unix.IN_DELETE_SELF {
+				delete(w.paths, int(raw.Wd))
+				delete(w.watches, name)
+			}
+			w.mu.Unlock()
+
+			if nameLen > 0 {
+
+				bytes := (*[unix.PathMax]byte)(unsafe.Pointer(&buf[offset+unix.SizeofInotifyEvent]))[:nameLen:nameLen]
+
+				name += "/" + strings.TrimRight(string(bytes[0:nameLen]), "\000")
+			}
+
+			event := w.newEvent(name, mask)
+
+			if mask&unix.IN_IGNORED == 0 {
+				if !w.sendEvent(event) {
+					return
+				}
+			}
+
+			offset += unix.SizeofInotifyEvent + nameLen
+		}
+	}
+}
+
+func (w *Watcher) newEvent(name string, mask uint32) Event {
+	e := Event{Name: name}
+	if mask&unix.IN_CREATE == unix.IN_CREATE || mask&unix.IN_MOVED_TO == unix.IN_MOVED_TO {
+		e.Op |= Create
+	}
+	if mask&unix.IN_DELETE_SELF == unix.IN_DELETE_SELF || mask&unix.IN_DELETE == unix.IN_DELETE {
+		e.Op |= Remove
+	}
+	if mask&unix.IN_MODIFY == unix.IN_MODIFY {
+		e.Op |= Write
+	}
+	if mask&unix.IN_MOVE_SELF == unix.IN_MOVE_SELF || mask&unix.IN_MOVED_FROM == unix.IN_MOVED_FROM {
+		e.Op |= Rename
+	}
+	if mask&unix.IN_ATTRIB == unix.IN_ATTRIB {
+		e.Op |= Chmod
+	}
+	return e
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/backend_inotify_test.go b/go_package_port/github.com/fsnotify/fsnotify/backend_inotify_test.go
new file mode 100644
index 0000000..0b6c918
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/backend_inotify_test.go
@@ -0,0 +1,191 @@
+//go:build linux
+// +build linux
+
+package fsnotify
+
+import (
+	"errors"
+	"fmt"
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+	"sync"
+	"testing"
+	"time"
+)
+
+// Make sure there are no additional threads being created.
+//
+// TODO: should generalize this and run for all backends.
+func TestInotifyNoBlockingSyscalls(t *testing.T) {
+	test := func() error {
+		getThreads := func() (int, error) {
+			// return pprof.Lookup("threadcreate").Count()
+			d := fmt.Sprintf("/proc/%d/task", os.Getpid())
+			ls, err := os.ReadDir(d)
+			if err != nil {
+				return 0, fmt.Errorf("reading %q: %s", d, err)
+			}
+			return len(ls), nil
+		}
+
+		w := newWatcher(t)
+		start, err := getThreads()
+		if err != nil {
+			return err
+		}
+
+		// Call readEvents a bunch of times; if this function has a blocking raw
+		// syscall, it'll create many new kthreads
+		for i := 0; i <= 60; i++ {
+			go w.readEvents()
+		}
+
+		time.Sleep(2 * time.Second)
+
+		end, err := getThreads()
+		if err != nil {
+			return err
+		}
+		if diff := end - start; diff > 0 {
+			return fmt.Errorf("Got a nonzero diff %v. starting: %v. ending: %v", diff, start, end)
+		}
+		return nil
+	}
+
+	// This test can be a bit flaky, so run it twice and consider it "failed"
+	// only if both fail.
+	err := test()
+	if err != nil {
+		time.Sleep(2 * time.Second)
+		err := test()
+		if err != nil {
+			t.Fatal(err)
+		}
+	}
+}
+
+// Ensure that the correct error is returned on overflows.
+func TestInotifyOverflow(t *testing.T) {
+	t.Parallel()
+
+	tmp := t.TempDir()
+	w := newWatcher(t)
+	defer w.Close()
+
+	// We need to generate many more events than the
+	// fs.inotify.max_queued_events sysctl setting.
+	numDirs, numFiles := 128, 1024
+
+	// All events need to be in the inotify queue before pulling events off it
+	// to trigger this error.
+	var wg sync.WaitGroup
+	for i := 0; i < numDirs; i++ {
+		wg.Add(1)
+		go func(i int) {
+			defer wg.Done()
+
+			dir := filepath.Join(tmp, strconv.Itoa(i))
+			mkdir(t, dir, noWait)
+			addWatch(t, w, dir)
+
+			createFiles(t, dir, "", numFiles, 10*time.Second)
+		}(i)
+	}
+	wg.Wait()
+
+	var (
+		creates   = 0
+		overflows = 0
+	)
+	for overflows == 0 && creates < numDirs*numFiles {
+		select {
+		case <-time.After(10 * time.Second):
+			t.Fatalf("Not done")
+		case err := <-w.Errors:
+			if !errors.Is(err, ErrEventOverflow) {
+				t.Fatalf("unexpected error from watcher: %v", err)
+			}
+			overflows++
+		case e := <-w.Events:
+			if !strings.HasPrefix(e.Name, tmp) {
+				t.Fatalf("Event for unknown file: %s", e.Name)
+			}
+			if e.Op == Create {
+				creates++
+			}
+		}
+	}
+
+	if creates == numDirs*numFiles {
+		t.Fatalf("could not trigger overflow")
+	}
+	if overflows == 0 {
+		t.Fatalf("no overflow and not enough CREATE events (expected %d, got %d)",
+			numDirs*numFiles, creates)
+	}
+}
+
+// Test inotify's "we don't send REMOVE until all file descriptors are removed"
+// behaviour.
+func TestInotifyDeleteOpenFile(t *testing.T) {
+	t.Parallel()
+
+	tmp := t.TempDir()
+	file := filepath.Join(tmp, "file")
+
+	touch(t, file)
+	fp, err := os.Open(file)
+	if err != nil {
+		t.Fatalf("Create failed: %v", err)
+	}
+	defer fp.Close()
+
+	w := newCollector(t, file)
+	w.collect(t)
+
+	rm(t, file)
+	e := w.events(t)
+	cmpEvents(t, tmp, e, newEvents(t, `chmod /file`))
+
+	fp.Close()
+	e = w.stop(t)
+	cmpEvents(t, tmp, e, newEvents(t, `remove /file`))
+}
+
+func TestRemoveState(t *testing.T) {
+	var (
+		tmp  = t.TempDir()
+		dir  = filepath.Join(tmp, "dir")
+		file = filepath.Join(dir, "file")
+	)
+	mkdir(t, dir)
+	touch(t, file)
+
+	w := newWatcher(t, tmp)
+	addWatch(t, w, tmp)
+	addWatch(t, w, file)
+
+	check := func(want int) {
+		t.Helper()
+		if len(w.watches) != want {
+			t.Error(w.watches)
+		}
+		if len(w.paths) != want {
+			t.Error(w.paths)
+		}
+	}
+
+	check(2)
+
+	if err := w.Remove(file); err != nil {
+		t.Fatal(err)
+	}
+	check(1)
+
+	if err := w.Remove(tmp); err != nil {
+		t.Fatal(err)
+	}
+	check(0)
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/backend_kqueue.go b/go_package_port/github.com/fsnotify/fsnotify/backend_kqueue.go
new file mode 100644
index 0000000..2908746
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/backend_kqueue.go
@@ -0,0 +1,707 @@
+//go:build freebsd || openbsd || netbsd || dragonfly || darwin
+// +build freebsd openbsd netbsd dragonfly darwin
+
+package fsnotify
+
+import (
+	"errors"
+	"fmt"
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"sync"
+
+	"golang.org/x/sys/unix"
+)
+
+// Watcher watches a set of paths, delivering events on a channel.
+//
+// A watcher should not be copied (e.g. pass it by pointer, rather than by
+// value).
+//
+// # Linux notes
+//
+// When a file is removed a Remove event won't be emitted until all file
+// descriptors are closed, and deletes will always emit a Chmod. For example:
+//
+//     fp := os.Open("file")
+//     os.Remove("file")        // Triggers Chmod
+//     fp.Close()               // Triggers Remove
+//
+// This is the event that inotify sends, so not much can be changed about this.
+//
+// The fs.inotify.max_user_watches sysctl variable specifies the upper limit
+// for the number of watches per user, and fs.inotify.max_user_instances
+// specifies the maximum number of inotify instances per user. Every Watcher you
+// create is an "instance", and every path you add is a "watch".
+//
+// These are also exposed in /proc as /proc/sys/fs/inotify/max_user_watches and
+// /proc/sys/fs/inotify/max_user_instances
+//
+// To increase them you can use sysctl or write the value to the /proc file:
+//
+//     # Default values on Linux 5.18
+//     sysctl fs.inotify.max_user_watches=124983
+//     sysctl fs.inotify.max_user_instances=128
+//
+// To make the changes persist on reboot edit /etc/sysctl.conf or
+// /usr/lib/sysctl.d/50-default.conf (details differ per Linux distro; check
+// your distro's documentation):
+//
+//     fs.inotify.max_user_watches=124983
+//     fs.inotify.max_user_instances=128
+//
+// Reaching the limit will result in a "no space left on device" or "too many open
+// files" error.
+//
+// # kqueue notes (macOS, BSD)
+//
+// kqueue requires opening a file descriptor for every file that's being watched;
+// so if you're watching a directory with five files then that's six file
+// descriptors. You will run in to your system's "max open files" limit faster on
+// these platforms.
+//
+// The sysctl variables kern.maxfiles and kern.maxfilesperproc can be used to
+// control the maximum number of open files, as well as /etc/login.conf on BSD
+// systems.
+//
+// # macOS notes
+//
+// Spotlight indexing on macOS can result in multiple events (see [#15]). A
+// temporary workaround is to add your folder(s) to the "Spotlight Privacy
+// Settings" until we have a native FSEvents implementation (see [#11]).
+//
+// [#11]: https://github.com/fsnotify/fsnotify/issues/11
+// [#15]: https://github.com/fsnotify/fsnotify/issues/15
+type Watcher struct {
+	// Events sends the filesystem change events.
+	//
+	// fsnotify can send the following events; a "path" here can refer to a
+	// file, directory, symbolic link, or special file like a FIFO.
+	//
+	//   fsnotify.Create    A new path was created; this may be followed by one
+	//                      or more Write events if data also gets written to a
+	//                      file.
+	//
+	//   fsnotify.Remove    A path was removed.
+	//
+	//   fsnotify.Rename    A path was renamed. A rename is always sent with the
+	//                      old path as Event.Name, and a Create event will be
+	//                      sent with the new name. Renames are only sent for
+	//                      paths that are currently watched; e.g. moving an
+	//                      unmonitored file into a monitored directory will
+	//                      show up as just a Create. Similarly, renaming a file
+	//                      to outside a monitored directory will show up as
+	//                      only a Rename.
+	//
+	//   fsnotify.Write     A file or named pipe was written to. A Truncate will
+	//                      also trigger a Write. A single "write action"
+	//                      initiated by the user may show up as one or multiple
+	//                      writes, depending on when the system syncs things to
+	//                      disk. For example when compiling a large Go program
+	//                      you may get hundreds of Write events, so you
+	//                      probably want to wait until you've stopped receiving
+	//                      them (see the dedup example in cmd/fsnotify).
+	//
+	//   fsnotify.Chmod     Attributes were changed. On Linux this is also sent
+	//                      when a file is removed (or more accurately, when a
+	//                      link to an inode is removed). On kqueue it's sent
+	//                      and on kqueue when a file is truncated. On Windows
+	//                      it's never sent.
+	Events chan Event
+
+	// Errors sends any errors.
+	Errors chan error
+
+	done         chan struct{}
+	kq           int                         // File descriptor (as returned by the kqueue() syscall).
+	closepipe    [2]int                      // Pipe used for closing.
+	mu           sync.Mutex                  // Protects access to watcher data
+	watches      map[string]int              // Watched file descriptors (key: path).
+	watchesByDir map[string]map[int]struct{} // Watched file descriptors indexed by the parent directory (key: dirname(path)).
+	userWatches  map[string]struct{}         // Watches added with Watcher.Add()
+	dirFlags     map[string]uint32           // Watched directories to fflags used in kqueue.
+	paths        map[int]pathInfo            // File descriptors to path names for processing kqueue events.
+	fileExists   map[string]struct{}         // Keep track of if we know this file exists (to stop duplicate create events).
+	isClosed     bool                        // Set to true when Close() is first called
+}
+
+type pathInfo struct {
+	name  string
+	isDir bool
+}
+
+// NewWatcher creates a new Watcher.
+func NewWatcher() (*Watcher, error) {
+	kq, closepipe, err := newKqueue()
+	if err != nil {
+		return nil, err
+	}
+
+	w := &Watcher{
+		kq:           kq,
+		closepipe:    closepipe,
+		watches:      make(map[string]int),
+		watchesByDir: make(map[string]map[int]struct{}),
+		dirFlags:     make(map[string]uint32),
+		paths:        make(map[int]pathInfo),
+		fileExists:   make(map[string]struct{}),
+		userWatches:  make(map[string]struct{}),
+		Events:       make(chan Event),
+		Errors:       make(chan error),
+		done:         make(chan struct{}),
+	}
+
+	go w.readEvents()
+	return w, nil
+}
+
+// newKqueue creates a new kernel event queue and returns a descriptor.
+//
+// This registers a new event on closepipe, which will trigger an event when
+// it's closed. This way we can use kevent() without timeout/polling; without
+// the closepipe, it would block forever and we wouldn't be able to stop it at
+// all.
+func newKqueue() (kq int, closepipe [2]int, err error) {
+	kq, err = unix.Kqueue()
+	if kq == -1 {
+		return kq, closepipe, err
+	}
+
+	// Register the close pipe.
+	err = unix.Pipe(closepipe[:])
+	if err != nil {
+		unix.Close(kq)
+		return kq, closepipe, err
+	}
+
+	// Register changes to listen on the closepipe.
+	changes := make([]unix.Kevent_t, 1)
+	// SetKevent converts int to the platform-specific types.
+	unix.SetKevent(&changes[0], closepipe[0], unix.EVFILT_READ,
+		unix.EV_ADD|unix.EV_ENABLE|unix.EV_ONESHOT)
+
+	ok, err := unix.Kevent(kq, changes, nil, nil)
+	if ok == -1 {
+		unix.Close(kq)
+		unix.Close(closepipe[0])
+		unix.Close(closepipe[1])
+		return kq, closepipe, err
+	}
+	return kq, closepipe, nil
+}
+
+// Returns true if the event was sent, or false if watcher is closed.
+func (w *Watcher) sendEvent(e Event) bool {
+	select {
+	case w.Events <- e:
+		return true
+	case <-w.done:
+	}
+	return false
+}
+
+// Returns true if the error was sent, or false if watcher is closed.
+func (w *Watcher) sendError(err error) bool {
+	select {
+	case w.Errors <- err:
+		return true
+	case <-w.done:
+	}
+	return false
+}
+
+// Close removes all watches and closes the events channel.
+func (w *Watcher) Close() error {
+	w.mu.Lock()
+	if w.isClosed {
+		w.mu.Unlock()
+		return nil
+	}
+	w.isClosed = true
+
+	// copy paths to remove while locked
+	pathsToRemove := make([]string, 0, len(w.watches))
+	for name := range w.watches {
+		pathsToRemove = append(pathsToRemove, name)
+	}
+	w.mu.Unlock() // Unlock before calling Remove, which also locks
+	for _, name := range pathsToRemove {
+		w.Remove(name)
+	}
+
+	// Send "quit" message to the reader goroutine.
+	unix.Close(w.closepipe[1])
+	close(w.done)
+
+	return nil
+}
+
+// Add starts monitoring the path for changes.
+//
+// A path can only be watched once; attempting to watch it more than once will
+// return an error. Paths that do not yet exist on the filesystem cannot be
+// added. A watch will be automatically removed if the path is deleted.
+//
+// A path will remain watched if it gets renamed to somewhere else on the same
+// filesystem, but the monitor will get removed if the path gets deleted and
+// re-created, or if it's moved to a different filesystem.
+//
+// Notifications on network filesystems (NFS, SMB, FUSE, etc.) or special
+// filesystems (/proc, /sys, etc.) generally don't work.
+//
+// # Watching directories
+//
+// All files in a directory are monitored, including new files that are created
+// after the watcher is started. Subdirectories are not watched (i.e. it's
+// non-recursive).
+//
+// # Watching files
+//
+// Watching individual files (rather than directories) is generally not
+// recommended as many tools update files atomically. Instead of "just" writing
+// to the file a temporary file will be written to first, and if successful the
+// temporary file is moved to to destination removing the original, or some
+// variant thereof. The watcher on the original file is now lost, as it no
+// longer exists.
+//
+// Instead, watch the parent directory and use Event.Name to filter out files
+// you're not interested in. There is an example of this in [cmd/fsnotify/file.go].
+func (w *Watcher) Add(name string) error {
+	w.mu.Lock()
+	w.userWatches[name] = struct{}{}
+	w.mu.Unlock()
+	_, err := w.addWatch(name, noteAllEvents)
+	return err
+}
+
+// Remove stops monitoring the path for changes.
+//
+// Directories are always removed non-recursively. For example, if you added
+// /tmp/dir and /tmp/dir/subdir then you will need to remove both.
+//
+// Removing a path that has not yet been added returns [ErrNonExistentWatch].
+func (w *Watcher) Remove(name string) error {
+	name = filepath.Clean(name)
+	w.mu.Lock()
+	watchfd, ok := w.watches[name]
+	w.mu.Unlock()
+	if !ok {
+		return fmt.Errorf("%w: %s", ErrNonExistentWatch, name)
+	}
+
+	err := w.register([]int{watchfd}, unix.EV_DELETE, 0)
+	if err != nil {
+		return err
+	}
+
+	unix.Close(watchfd)
+
+	w.mu.Lock()
+	isDir := w.paths[watchfd].isDir
+	delete(w.watches, name)
+	delete(w.userWatches, name)
+
+	parentName := filepath.Dir(name)
+	delete(w.watchesByDir[parentName], watchfd)
+
+	if len(w.watchesByDir[parentName]) == 0 {
+		delete(w.watchesByDir, parentName)
+	}
+
+	delete(w.paths, watchfd)
+	delete(w.dirFlags, name)
+	delete(w.fileExists, name)
+	w.mu.Unlock()
+
+	// Find all watched paths that are in this directory that are not external.
+	if isDir {
+		var pathsToRemove []string
+		w.mu.Lock()
+		for fd := range w.watchesByDir[name] {
+			path := w.paths[fd]
+			if _, ok := w.userWatches[path.name]; !ok {
+				pathsToRemove = append(pathsToRemove, path.name)
+			}
+		}
+		w.mu.Unlock()
+		for _, name := range pathsToRemove {
+			// Since these are internal, not much sense in propagating error
+			// to the user, as that will just confuse them with an error about
+			// a path they did not explicitly watch themselves.
+			w.Remove(name)
+		}
+	}
+
+	return nil
+}
+
+// WatchList returns all paths added with [Add] (and are not yet removed).
+func (w *Watcher) WatchList() []string {
+	w.mu.Lock()
+	defer w.mu.Unlock()
+
+	entries := make([]string, 0, len(w.userWatches))
+	for pathname := range w.userWatches {
+		entries = append(entries, pathname)
+	}
+
+	return entries
+}
+
+// Watch all events (except NOTE_EXTEND, NOTE_LINK, NOTE_REVOKE)
+const noteAllEvents = unix.NOTE_DELETE | unix.NOTE_WRITE | unix.NOTE_ATTRIB | unix.NOTE_RENAME
+
+// addWatch adds name to the watched file set.
+// The flags are interpreted as described in kevent(2).
+// Returns the real path to the file which was added, if any, which may be different from the one passed in the case of symlinks.
+func (w *Watcher) addWatch(name string, flags uint32) (string, error) {
+	var isDir bool
+	// Make ./name and name equivalent
+	name = filepath.Clean(name)
+
+	w.mu.Lock()
+	if w.isClosed {
+		w.mu.Unlock()
+		return "", errors.New("kevent instance already closed")
+	}
+	watchfd, alreadyWatching := w.watches[name]
+	// We already have a watch, but we can still override flags.
+	if alreadyWatching {
+		isDir = w.paths[watchfd].isDir
+	}
+	w.mu.Unlock()
+
+	if !alreadyWatching {
+		fi, err := os.Lstat(name)
+		if err != nil {
+			return "", err
+		}
+
+		// Don't watch sockets or named pipes
+		if (fi.Mode()&os.ModeSocket == os.ModeSocket) || (fi.Mode()&os.ModeNamedPipe == os.ModeNamedPipe) {
+			return "", nil
+		}
+
+		// Follow Symlinks
+		//
+		// Linux can add unresolvable symlinks to the watch list without issue,
+		// and Windows can't do symlinks period. To maintain consistency, we
+		// will act like everything is fine if the link can't be resolved.
+		// There will simply be no file events for broken symlinks. Hence the
+		// returns of nil on errors.
+		if fi.Mode()&os.ModeSymlink == os.ModeSymlink {
+			name, err = filepath.EvalSymlinks(name)
+			if err != nil {
+				return "", nil
+			}
+
+			w.mu.Lock()
+			_, alreadyWatching = w.watches[name]
+			w.mu.Unlock()
+
+			if alreadyWatching {
+				return name, nil
+			}
+
+			fi, err = os.Lstat(name)
+			if err != nil {
+				return "", nil
+			}
+		}
+
+		// Retry on EINTR; open() can return EINTR in practice on macOS.
+		// See #354, and go issues 11180 and 39237.
+		for {
+			watchfd, err = unix.Open(name, openMode, 0)
+			if err == nil {
+				break
+			}
+			if errors.Is(err, unix.EINTR) {
+				continue
+			}
+
+			return "", err
+		}
+
+		isDir = fi.IsDir()
+	}
+
+	err := w.register([]int{watchfd}, unix.EV_ADD|unix.EV_CLEAR|unix.EV_ENABLE, flags)
+	if err != nil {
+		unix.Close(watchfd)
+		return "", err
+	}
+
+	if !alreadyWatching {
+		w.mu.Lock()
+		parentName := filepath.Dir(name)
+		w.watches[name] = watchfd
+
+		watchesByDir, ok := w.watchesByDir[parentName]
+		if !ok {
+			watchesByDir = make(map[int]struct{}, 1)
+			w.watchesByDir[parentName] = watchesByDir
+		}
+		watchesByDir[watchfd] = struct{}{}
+
+		w.paths[watchfd] = pathInfo{name: name, isDir: isDir}
+		w.mu.Unlock()
+	}
+
+	if isDir {
+		// Watch the directory if it has not been watched before,
+		// or if it was watched before, but perhaps only a NOTE_DELETE (watchDirectoryFiles)
+		w.mu.Lock()
+
+		watchDir := (flags&unix.NOTE_WRITE) == unix.NOTE_WRITE &&
+			(!alreadyWatching || (w.dirFlags[name]&unix.NOTE_WRITE) != unix.NOTE_WRITE)
+		// Store flags so this watch can be updated later
+		w.dirFlags[name] = flags
+		w.mu.Unlock()
+
+		if watchDir {
+			if err := w.watchDirectoryFiles(name); err != nil {
+				return "", err
+			}
+		}
+	}
+	return name, nil
+}
+
+// readEvents reads from kqueue and converts the received kevents into
+// Event values that it sends down the Events channel.
+func (w *Watcher) readEvents() {
+	defer func() {
+		err := unix.Close(w.kq)
+		if err != nil {
+			w.Errors <- err
+		}
+		unix.Close(w.closepipe[0])
+		close(w.Events)
+		close(w.Errors)
+	}()
+
+	eventBuffer := make([]unix.Kevent_t, 10)
+	for closed := false; !closed; {
+		kevents, err := w.read(eventBuffer)
+		// EINTR is okay, the syscall was interrupted before timeout expired.
+		if err != nil && err != unix.EINTR {
+			if !w.sendError(fmt.Errorf("fsnotify.readEvents: %w", err)) {
+				closed = true
+			}
+			continue
+		}
+
+		// Flush the events we received to the Events channel
+		for _, kevent := range kevents {
+			var (
+				watchfd = int(kevent.Ident)
+				mask    = uint32(kevent.Fflags)
+			)
+
+			// Shut down the loop when the pipe is closed, but only after all
+			// other events have been processed.
+			if watchfd == w.closepipe[0] {
+				closed = true
+				continue
+			}
+
+			w.mu.Lock()
+			path := w.paths[watchfd]
+			w.mu.Unlock()
+
+			event := w.newEvent(path.name, mask)
+
+			if path.isDir && !event.Has(Remove) {
+				// Double check to make sure the directory exists. This can
+				// happen when we do a rm -fr on a recursively watched folders
+				// and we receive a modification event first but the folder has
+				// been deleted and later receive the delete event.
+				if _, err := os.Lstat(event.Name); os.IsNotExist(err) {
+					event.Op |= Remove
+				}
+			}
+
+			if event.Has(Rename) || event.Has(Remove) {
+				w.Remove(event.Name)
+				w.mu.Lock()
+				delete(w.fileExists, event.Name)
+				w.mu.Unlock()
+			}
+
+			if path.isDir && event.Has(Write) && !event.Has(Remove) {
+				w.sendDirectoryChangeEvents(event.Name)
+			} else {
+				if !w.sendEvent(event) {
+					closed = true
+					continue
+				}
+			}
+
+			if event.Has(Remove) {
+				// Look for a file that may have overwritten this.
+				// For example, mv f1 f2 will delete f2, then create f2.
+				if path.isDir {
+					fileDir := filepath.Clean(event.Name)
+					w.mu.Lock()
+					_, found := w.watches[fileDir]
+					w.mu.Unlock()
+					if found {
+						// make sure the directory exists before we watch for changes. When we
+						// do a recursive watch and perform rm -fr, the parent directory might
+						// have gone missing, ignore the missing directory and let the
+						// upcoming delete event remove the watch from the parent directory.
+						if _, err := os.Lstat(fileDir); err == nil {
+							w.sendDirectoryChangeEvents(fileDir)
+						}
+					}
+				} else {
+					filePath := filepath.Clean(event.Name)
+					if fileInfo, err := os.Lstat(filePath); err == nil {
+						w.sendFileCreatedEventIfNew(filePath, fileInfo)
+					}
+				}
+			}
+		}
+	}
+}
+
+// newEvent returns an platform-independent Event based on kqueue Fflags.
+func (w *Watcher) newEvent(name string, mask uint32) Event {
+	e := Event{Name: name}
+	if mask&unix.NOTE_DELETE == unix.NOTE_DELETE {
+		e.Op |= Remove
+	}
+	if mask&unix.NOTE_WRITE == unix.NOTE_WRITE {
+		e.Op |= Write
+	}
+	if mask&unix.NOTE_RENAME == unix.NOTE_RENAME {
+		e.Op |= Rename
+	}
+	if mask&unix.NOTE_ATTRIB == unix.NOTE_ATTRIB {
+		e.Op |= Chmod
+	}
+	return e
+}
+
+// watchDirectoryFiles to mimic inotify when adding a watch on a directory
+func (w *Watcher) watchDirectoryFiles(dirPath string) error {
+	// Get all files
+	files, err := ioutil.ReadDir(dirPath)
+	if err != nil {
+		return err
+	}
+
+	for _, fileInfo := range files {
+		path := filepath.Join(dirPath, fileInfo.Name())
+
+		cleanPath, err := w.internalWatch(path, fileInfo)
+		if err != nil {
+			// No permission to read the file; that's not a problem: just skip.
+			// But do add it to w.fileExists to prevent it from being picked up
+			// as a "new" file later (it still shows up in the directory
+			// listing).
+			switch {
+			case errors.Is(err, unix.EACCES) || errors.Is(err, unix.EPERM):
+				cleanPath = filepath.Clean(path)
+			default:
+				return fmt.Errorf("%q: %w", filepath.Join(dirPath, fileInfo.Name()), err)
+			}
+		}
+
+		w.mu.Lock()
+		w.fileExists[cleanPath] = struct{}{}
+		w.mu.Unlock()
+	}
+
+	return nil
+}
+
+// Search the directory for new files and send an event for them.
+//
+// This functionality is to have the BSD watcher match the inotify, which sends
+// a create event for files created in a watched directory.
+func (w *Watcher) sendDirectoryChangeEvents(dir string) {
+	// Get all files
+	files, err := ioutil.ReadDir(dir)
+	if err != nil {
+		if !w.sendError(fmt.Errorf("fsnotify.sendDirectoryChangeEvents: %w", err)) {
+			return
+		}
+	}
+
+	// Search for new files
+	for _, fi := range files {
+		err := w.sendFileCreatedEventIfNew(filepath.Join(dir, fi.Name()), fi)
+		if err != nil {
+			return
+		}
+	}
+}
+
+// sendFileCreatedEvent sends a create event if the file isn't already being tracked.
+func (w *Watcher) sendFileCreatedEventIfNew(filePath string, fileInfo os.FileInfo) (err error) {
+	w.mu.Lock()
+	_, doesExist := w.fileExists[filePath]
+	w.mu.Unlock()
+	if !doesExist {
+		if !w.sendEvent(Event{Name: filePath, Op: Create}) {
+			return
+		}
+	}
+
+	// like watchDirectoryFiles (but without doing another ReadDir)
+	filePath, err = w.internalWatch(filePath, fileInfo)
+	if err != nil {
+		return err
+	}
+
+	w.mu.Lock()
+	w.fileExists[filePath] = struct{}{}
+	w.mu.Unlock()
+
+	return nil
+}
+
+func (w *Watcher) internalWatch(name string, fileInfo os.FileInfo) (string, error) {
+	if fileInfo.IsDir() {
+		// mimic Linux providing delete events for subdirectories
+		// but preserve the flags used if currently watching subdirectory
+		w.mu.Lock()
+		flags := w.dirFlags[name]
+		w.mu.Unlock()
+
+		flags |= unix.NOTE_DELETE | unix.NOTE_RENAME
+		return w.addWatch(name, flags)
+	}
+
+	// watch file to mimic Linux inotify
+	return w.addWatch(name, noteAllEvents)
+}
+
+// Register events with the queue.
+func (w *Watcher) register(fds []int, flags int, fflags uint32) error {
+	changes := make([]unix.Kevent_t, len(fds))
+	for i, fd := range fds {
+		// SetKevent converts int to the platform-specific types.
+		unix.SetKevent(&changes[i], fd, unix.EVFILT_VNODE, flags)
+		changes[i].Fflags = fflags
+	}
+
+	// Register the events.
+	success, err := unix.Kevent(w.kq, changes, nil, nil)
+	if success == -1 {
+		return err
+	}
+	return nil
+}
+
+// read retrieves pending events, or waits until an event occurs.
+func (w *Watcher) read(events []unix.Kevent_t) ([]unix.Kevent_t, error) {
+	n, err := unix.Kevent(w.kq, nil, events, nil)
+	if err != nil {
+		return nil, err
+	}
+	return events[0:n], nil
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/backend_kqueue_test.go b/go_package_port/github.com/fsnotify/fsnotify/backend_kqueue_test.go
new file mode 100644
index 0000000..590d985
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/backend_kqueue_test.go
@@ -0,0 +1,97 @@
+//go:build freebsd || openbsd || netbsd || dragonfly || darwin
+// +build freebsd openbsd netbsd dragonfly darwin
+
+package fsnotify
+
+import (
+	"fmt"
+	"path/filepath"
+	"strings"
+	"testing"
+)
+
+func TestRemoveState(t *testing.T) {
+	var (
+		tmp  = t.TempDir()
+		dir  = filepath.Join(tmp, "dir")
+		file = filepath.Join(dir, "file")
+	)
+	mkdir(t, dir)
+	touch(t, file)
+
+	w := newWatcher(t, tmp)
+	addWatch(t, w, tmp)
+	addWatch(t, w, file)
+
+	check := func(wantUser, wantTotal int) {
+		t.Helper()
+
+		if len(w.watches) != wantTotal {
+			var d []string
+			for k, v := range w.watches {
+				d = append(d, fmt.Sprintf("%#v = %#v", k, v))
+			}
+			t.Errorf("unexpected number of entries in w.watches (have %d, want %d):\n%v",
+				len(w.watches), wantTotal, strings.Join(d, "\n"))
+		}
+		if len(w.paths) != wantTotal {
+			var d []string
+			for k, v := range w.paths {
+				d = append(d, fmt.Sprintf("%#v = %#v", k, v))
+			}
+			t.Errorf("unexpected number of entries in w.paths (have %d, want %d):\n%v",
+				len(w.paths), wantTotal, strings.Join(d, "\n"))
+		}
+		if len(w.userWatches) != wantUser {
+			var d []string
+			for k, v := range w.userWatches {
+				d = append(d, fmt.Sprintf("%#v = %#v", k, v))
+			}
+			t.Errorf("unexpected number of entries in w.userWatches (have %d, want %d):\n%v",
+				len(w.userWatches), wantUser, strings.Join(d, "\n"))
+		}
+	}
+
+	check(2, 3)
+
+	if err := w.Remove(file); err != nil {
+		t.Fatal(err)
+	}
+	check(1, 2)
+
+	if err := w.Remove(tmp); err != nil {
+		t.Fatal(err)
+	}
+	check(0, 0)
+
+	// Don't check these after ever remove since they don't map easily to number
+	// of files watches. Just make sure they're 0 after everything is removed.
+	{
+		want := 0
+		if len(w.watchesByDir) != want {
+			var d []string
+			for k, v := range w.watchesByDir {
+				d = append(d, fmt.Sprintf("%#v = %#v", k, v))
+			}
+			t.Errorf("unexpected number of entries in w.watchesByDir (have %d, want %d):\n%v",
+				len(w.watchesByDir), want, strings.Join(d, "\n"))
+		}
+		if len(w.dirFlags) != want {
+			var d []string
+			for k, v := range w.dirFlags {
+				d = append(d, fmt.Sprintf("%#v = %#v", k, v))
+			}
+			t.Errorf("unexpected number of entries in w.dirFlags (have %d, want %d):\n%v",
+				len(w.dirFlags), want, strings.Join(d, "\n"))
+		}
+
+		if len(w.fileExists) != want {
+			var d []string
+			for k, v := range w.fileExists {
+				d = append(d, fmt.Sprintf("%#v = %#v", k, v))
+			}
+			t.Errorf("unexpected number of entries in w.fileExists (have %d, want %d):\n%v",
+				len(w.fileExists), want, strings.Join(d, "\n"))
+		}
+	}
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/backend_other.go b/go_package_port/github.com/fsnotify/fsnotify/backend_other.go
new file mode 100644
index 0000000..0b64101
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/backend_other.go
@@ -0,0 +1,28 @@
+//go:build !zos
+
+// Tags altered by Wharf (added !zos)
+//
+package fsnotify
+
+import (
+	"fmt"
+	"runtime"
+)
+
+type Watcher struct{}
+
+func NewWatcher() (*Watcher, error) {
+	return nil, fmt.Errorf("fsnotify not supported on %s", runtime.GOOS)
+}
+
+func (w *Watcher) Close() error {
+	return nil
+}
+
+func (w *Watcher) Add(name string) error {
+	return nil
+}
+
+func (w *Watcher) Remove(name string) error {
+	return nil
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/backend_windows.go b/go_package_port/github.com/fsnotify/fsnotify/backend_windows.go
new file mode 100644
index 0000000..ae39286
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/backend_windows.go
@@ -0,0 +1,746 @@
+//go:build windows
+// +build windows
+
+package fsnotify
+
+import (
+	"errors"
+	"fmt"
+	"os"
+	"path/filepath"
+	"reflect"
+	"runtime"
+	"strings"
+	"sync"
+	"unsafe"
+
+	"golang.org/x/sys/windows"
+)
+
+// Watcher watches a set of paths, delivering events on a channel.
+//
+// A watcher should not be copied (e.g. pass it by pointer, rather than by
+// value).
+//
+// # Linux notes
+//
+// When a file is removed a Remove event won't be emitted until all file
+// descriptors are closed, and deletes will always emit a Chmod. For example:
+//
+//     fp := os.Open("file")
+//     os.Remove("file")        // Triggers Chmod
+//     fp.Close()               // Triggers Remove
+//
+// This is the event that inotify sends, so not much can be changed about this.
+//
+// The fs.inotify.max_user_watches sysctl variable specifies the upper limit
+// for the number of watches per user, and fs.inotify.max_user_instances
+// specifies the maximum number of inotify instances per user. Every Watcher you
+// create is an "instance", and every path you add is a "watch".
+//
+// These are also exposed in /proc as /proc/sys/fs/inotify/max_user_watches and
+// /proc/sys/fs/inotify/max_user_instances
+//
+// To increase them you can use sysctl or write the value to the /proc file:
+//
+//     # Default values on Linux 5.18
+//     sysctl fs.inotify.max_user_watches=124983
+//     sysctl fs.inotify.max_user_instances=128
+//
+// To make the changes persist on reboot edit /etc/sysctl.conf or
+// /usr/lib/sysctl.d/50-default.conf (details differ per Linux distro; check
+// your distro's documentation):
+//
+//     fs.inotify.max_user_watches=124983
+//     fs.inotify.max_user_instances=128
+//
+// Reaching the limit will result in a "no space left on device" or "too many open
+// files" error.
+//
+// # kqueue notes (macOS, BSD)
+//
+// kqueue requires opening a file descriptor for every file that's being watched;
+// so if you're watching a directory with five files then that's six file
+// descriptors. You will run in to your system's "max open files" limit faster on
+// these platforms.
+//
+// The sysctl variables kern.maxfiles and kern.maxfilesperproc can be used to
+// control the maximum number of open files, as well as /etc/login.conf on BSD
+// systems.
+//
+// # macOS notes
+//
+// Spotlight indexing on macOS can result in multiple events (see [#15]). A
+// temporary workaround is to add your folder(s) to the "Spotlight Privacy
+// Settings" until we have a native FSEvents implementation (see [#11]).
+//
+// [#11]: https://github.com/fsnotify/fsnotify/issues/11
+// [#15]: https://github.com/fsnotify/fsnotify/issues/15
+type Watcher struct {
+	// Events sends the filesystem change events.
+	//
+	// fsnotify can send the following events; a "path" here can refer to a
+	// file, directory, symbolic link, or special file like a FIFO.
+	//
+	//   fsnotify.Create    A new path was created; this may be followed by one
+	//                      or more Write events if data also gets written to a
+	//                      file.
+	//
+	//   fsnotify.Remove    A path was removed.
+	//
+	//   fsnotify.Rename    A path was renamed. A rename is always sent with the
+	//                      old path as Event.Name, and a Create event will be
+	//                      sent with the new name. Renames are only sent for
+	//                      paths that are currently watched; e.g. moving an
+	//                      unmonitored file into a monitored directory will
+	//                      show up as just a Create. Similarly, renaming a file
+	//                      to outside a monitored directory will show up as
+	//                      only a Rename.
+	//
+	//   fsnotify.Write     A file or named pipe was written to. A Truncate will
+	//                      also trigger a Write. A single "write action"
+	//                      initiated by the user may show up as one or multiple
+	//                      writes, depending on when the system syncs things to
+	//                      disk. For example when compiling a large Go program
+	//                      you may get hundreds of Write events, so you
+	//                      probably want to wait until you've stopped receiving
+	//                      them (see the dedup example in cmd/fsnotify).
+	//
+	//   fsnotify.Chmod     Attributes were changed. On Linux this is also sent
+	//                      when a file is removed (or more accurately, when a
+	//                      link to an inode is removed). On kqueue it's sent
+	//                      and on kqueue when a file is truncated. On Windows
+	//                      it's never sent.
+	Events chan Event
+
+	// Errors sends any errors.
+	Errors chan error
+
+	port  windows.Handle // Handle to completion port
+	input chan *input    // Inputs to the reader are sent on this channel
+	quit  chan chan<- error
+
+	mu       sync.Mutex // Protects access to watches, isClosed
+	watches  watchMap   // Map of watches (key: i-number)
+	isClosed bool       // Set to true when Close() is first called
+}
+
+// NewWatcher creates a new Watcher.
+func NewWatcher() (*Watcher, error) {
+	port, err := windows.CreateIoCompletionPort(windows.InvalidHandle, 0, 0, 0)
+	if err != nil {
+		return nil, os.NewSyscallError("CreateIoCompletionPort", err)
+	}
+	w := &Watcher{
+		port:    port,
+		watches: make(watchMap),
+		input:   make(chan *input, 1),
+		Events:  make(chan Event, 50),
+		Errors:  make(chan error),
+		quit:    make(chan chan<- error, 1),
+	}
+	go w.readEvents()
+	return w, nil
+}
+
+func (w *Watcher) sendEvent(name string, mask uint64) bool {
+	if mask == 0 {
+		return false
+	}
+
+	event := w.newEvent(name, uint32(mask))
+	select {
+	case ch := <-w.quit:
+		w.quit <- ch
+	case w.Events <- event:
+	}
+	return true
+}
+
+// Returns true if the error was sent, or false if watcher is closed.
+func (w *Watcher) sendError(err error) bool {
+	select {
+	case w.Errors <- err:
+		return true
+	case <-w.quit:
+	}
+	return false
+}
+
+// Close removes all watches and closes the events channel.
+func (w *Watcher) Close() error {
+	w.mu.Lock()
+	if w.isClosed {
+		w.mu.Unlock()
+		return nil
+	}
+	w.isClosed = true
+	w.mu.Unlock()
+
+	// Send "quit" message to the reader goroutine
+	ch := make(chan error)
+	w.quit <- ch
+	if err := w.wakeupReader(); err != nil {
+		return err
+	}
+	return <-ch
+}
+
+// Add starts monitoring the path for changes.
+//
+// A path can only be watched once; attempting to watch it more than once will
+// return an error. Paths that do not yet exist on the filesystem cannot be
+// added. A watch will be automatically removed if the path is deleted.
+//
+// A path will remain watched if it gets renamed to somewhere else on the same
+// filesystem, but the monitor will get removed if the path gets deleted and
+// re-created, or if it's moved to a different filesystem.
+//
+// Notifications on network filesystems (NFS, SMB, FUSE, etc.) or special
+// filesystems (/proc, /sys, etc.) generally don't work.
+//
+// # Watching directories
+//
+// All files in a directory are monitored, including new files that are created
+// after the watcher is started. Subdirectories are not watched (i.e. it's
+// non-recursive).
+//
+// # Watching files
+//
+// Watching individual files (rather than directories) is generally not
+// recommended as many tools update files atomically. Instead of "just" writing
+// to the file a temporary file will be written to first, and if successful the
+// temporary file is moved to to destination removing the original, or some
+// variant thereof. The watcher on the original file is now lost, as it no
+// longer exists.
+//
+// Instead, watch the parent directory and use Event.Name to filter out files
+// you're not interested in. There is an example of this in [cmd/fsnotify/file.go].
+func (w *Watcher) Add(name string) error {
+	w.mu.Lock()
+	if w.isClosed {
+		w.mu.Unlock()
+		return errors.New("watcher already closed")
+	}
+	w.mu.Unlock()
+
+	in := &input{
+		op:    opAddWatch,
+		path:  filepath.Clean(name),
+		flags: sysFSALLEVENTS,
+		reply: make(chan error),
+	}
+	w.input <- in
+	if err := w.wakeupReader(); err != nil {
+		return err
+	}
+	return <-in.reply
+}
+
+// Remove stops monitoring the path for changes.
+//
+// Directories are always removed non-recursively. For example, if you added
+// /tmp/dir and /tmp/dir/subdir then you will need to remove both.
+//
+// Removing a path that has not yet been added returns [ErrNonExistentWatch].
+func (w *Watcher) Remove(name string) error {
+	in := &input{
+		op:    opRemoveWatch,
+		path:  filepath.Clean(name),
+		reply: make(chan error),
+	}
+	w.input <- in
+	if err := w.wakeupReader(); err != nil {
+		return err
+	}
+	return <-in.reply
+}
+
+// WatchList returns all paths added with [Add] (and are not yet removed).
+func (w *Watcher) WatchList() []string {
+	w.mu.Lock()
+	defer w.mu.Unlock()
+
+	entries := make([]string, 0, len(w.watches))
+	for _, entry := range w.watches {
+		for _, watchEntry := range entry {
+			entries = append(entries, watchEntry.path)
+		}
+	}
+
+	return entries
+}
+
+// These options are from the old golang.org/x/exp/winfsnotify, where you could
+// add various options to the watch. This has long since been removed.
+//
+// The "sys" in the name is misleading as they're not part of any "system".
+//
+// This should all be removed at some point, and just use windows.FILE_NOTIFY_*
+const (
+	sysFSALLEVENTS  = 0xfff
+	sysFSATTRIB     = 0x4
+	sysFSCREATE     = 0x100
+	sysFSDELETE     = 0x200
+	sysFSDELETESELF = 0x400
+	sysFSMODIFY     = 0x2
+	sysFSMOVE       = 0xc0
+	sysFSMOVEDFROM  = 0x40
+	sysFSMOVEDTO    = 0x80
+	sysFSMOVESELF   = 0x800
+	sysFSIGNORED    = 0x8000
+)
+
+func (w *Watcher) newEvent(name string, mask uint32) Event {
+	e := Event{Name: name}
+	if mask&sysFSCREATE == sysFSCREATE || mask&sysFSMOVEDTO == sysFSMOVEDTO {
+		e.Op |= Create
+	}
+	if mask&sysFSDELETE == sysFSDELETE || mask&sysFSDELETESELF == sysFSDELETESELF {
+		e.Op |= Remove
+	}
+	if mask&sysFSMODIFY == sysFSMODIFY {
+		e.Op |= Write
+	}
+	if mask&sysFSMOVE == sysFSMOVE || mask&sysFSMOVESELF == sysFSMOVESELF || mask&sysFSMOVEDFROM == sysFSMOVEDFROM {
+		e.Op |= Rename
+	}
+	if mask&sysFSATTRIB == sysFSATTRIB {
+		e.Op |= Chmod
+	}
+	return e
+}
+
+const (
+	opAddWatch = iota
+	opRemoveWatch
+)
+
+const (
+	provisional uint64 = 1 << (32 + iota)
+)
+
+type input struct {
+	op    int
+	path  string
+	flags uint32
+	reply chan error
+}
+
+type inode struct {
+	handle windows.Handle
+	volume uint32
+	index  uint64
+}
+
+type watch struct {
+	ov     windows.Overlapped
+	ino    *inode            // i-number
+	path   string            // Directory path
+	mask   uint64            // Directory itself is being watched with these notify flags
+	names  map[string]uint64 // Map of names being watched and their notify flags
+	rename string            // Remembers the old name while renaming a file
+	buf    [65536]byte       // 64K buffer
+}
+
+type (
+	indexMap map[uint64]*watch
+	watchMap map[uint32]indexMap
+)
+
+func (w *Watcher) wakeupReader() error {
+	err := windows.PostQueuedCompletionStatus(w.port, 0, 0, nil)
+	if err != nil {
+		return os.NewSyscallError("PostQueuedCompletionStatus", err)
+	}
+	return nil
+}
+
+func (w *Watcher) getDir(pathname string) (dir string, err error) {
+	attr, err := windows.GetFileAttributes(windows.StringToUTF16Ptr(pathname))
+	if err != nil {
+		return "", os.NewSyscallError("GetFileAttributes", err)
+	}
+	if attr&windows.FILE_ATTRIBUTE_DIRECTORY != 0 {
+		dir = pathname
+	} else {
+		dir, _ = filepath.Split(pathname)
+		dir = filepath.Clean(dir)
+	}
+	return
+}
+
+func (w *Watcher) getIno(path string) (ino *inode, err error) {
+	h, err := windows.CreateFile(windows.StringToUTF16Ptr(path),
+		windows.FILE_LIST_DIRECTORY,
+		windows.FILE_SHARE_READ|windows.FILE_SHARE_WRITE|windows.FILE_SHARE_DELETE,
+		nil, windows.OPEN_EXISTING,
+		windows.FILE_FLAG_BACKUP_SEMANTICS|windows.FILE_FLAG_OVERLAPPED, 0)
+	if err != nil {
+		return nil, os.NewSyscallError("CreateFile", err)
+	}
+
+	var fi windows.ByHandleFileInformation
+	err = windows.GetFileInformationByHandle(h, &fi)
+	if err != nil {
+		windows.CloseHandle(h)
+		return nil, os.NewSyscallError("GetFileInformationByHandle", err)
+	}
+	ino = &inode{
+		handle: h,
+		volume: fi.VolumeSerialNumber,
+		index:  uint64(fi.FileIndexHigh)<<32 | uint64(fi.FileIndexLow),
+	}
+	return ino, nil
+}
+
+// Must run within the I/O thread.
+func (m watchMap) get(ino *inode) *watch {
+	if i := m[ino.volume]; i != nil {
+		return i[ino.index]
+	}
+	return nil
+}
+
+// Must run within the I/O thread.
+func (m watchMap) set(ino *inode, watch *watch) {
+	i := m[ino.volume]
+	if i == nil {
+		i = make(indexMap)
+		m[ino.volume] = i
+	}
+	i[ino.index] = watch
+}
+
+// Must run within the I/O thread.
+func (w *Watcher) addWatch(pathname string, flags uint64) error {
+	dir, err := w.getDir(pathname)
+	if err != nil {
+		return err
+	}
+
+	ino, err := w.getIno(dir)
+	if err != nil {
+		return err
+	}
+	w.mu.Lock()
+	watchEntry := w.watches.get(ino)
+	w.mu.Unlock()
+	if watchEntry == nil {
+		_, err := windows.CreateIoCompletionPort(ino.handle, w.port, 0, 0)
+		if err != nil {
+			windows.CloseHandle(ino.handle)
+			return os.NewSyscallError("CreateIoCompletionPort", err)
+		}
+		watchEntry = &watch{
+			ino:   ino,
+			path:  dir,
+			names: make(map[string]uint64),
+		}
+		w.mu.Lock()
+		w.watches.set(ino, watchEntry)
+		w.mu.Unlock()
+		flags |= provisional
+	} else {
+		windows.CloseHandle(ino.handle)
+	}
+	if pathname == dir {
+		watchEntry.mask |= flags
+	} else {
+		watchEntry.names[filepath.Base(pathname)] |= flags
+	}
+
+	err = w.startRead(watchEntry)
+	if err != nil {
+		return err
+	}
+
+	if pathname == dir {
+		watchEntry.mask &= ^provisional
+	} else {
+		watchEntry.names[filepath.Base(pathname)] &= ^provisional
+	}
+	return nil
+}
+
+// Must run within the I/O thread.
+func (w *Watcher) remWatch(pathname string) error {
+	dir, err := w.getDir(pathname)
+	if err != nil {
+		return err
+	}
+	ino, err := w.getIno(dir)
+	if err != nil {
+		return err
+	}
+
+	w.mu.Lock()
+	watch := w.watches.get(ino)
+	w.mu.Unlock()
+
+	err = windows.CloseHandle(ino.handle)
+	if err != nil {
+		w.sendError(os.NewSyscallError("CloseHandle", err))
+	}
+	if watch == nil {
+		return fmt.Errorf("%w: %s", ErrNonExistentWatch, pathname)
+	}
+	if pathname == dir {
+		w.sendEvent(watch.path, watch.mask&sysFSIGNORED)
+		watch.mask = 0
+	} else {
+		name := filepath.Base(pathname)
+		w.sendEvent(filepath.Join(watch.path, name), watch.names[name]&sysFSIGNORED)
+		delete(watch.names, name)
+	}
+
+	return w.startRead(watch)
+}
+
+// Must run within the I/O thread.
+func (w *Watcher) deleteWatch(watch *watch) {
+	for name, mask := range watch.names {
+		if mask&provisional == 0 {
+			w.sendEvent(filepath.Join(watch.path, name), mask&sysFSIGNORED)
+		}
+		delete(watch.names, name)
+	}
+	if watch.mask != 0 {
+		if watch.mask&provisional == 0 {
+			w.sendEvent(watch.path, watch.mask&sysFSIGNORED)
+		}
+		watch.mask = 0
+	}
+}
+
+// Must run within the I/O thread.
+func (w *Watcher) startRead(watch *watch) error {
+	err := windows.CancelIo(watch.ino.handle)
+	if err != nil {
+		w.sendError(os.NewSyscallError("CancelIo", err))
+		w.deleteWatch(watch)
+	}
+	mask := w.toWindowsFlags(watch.mask)
+	for _, m := range watch.names {
+		mask |= w.toWindowsFlags(m)
+	}
+	if mask == 0 {
+		err := windows.CloseHandle(watch.ino.handle)
+		if err != nil {
+			w.sendError(os.NewSyscallError("CloseHandle", err))
+		}
+		w.mu.Lock()
+		delete(w.watches[watch.ino.volume], watch.ino.index)
+		w.mu.Unlock()
+		return nil
+	}
+
+	rdErr := windows.ReadDirectoryChanges(watch.ino.handle, &watch.buf[0],
+		uint32(unsafe.Sizeof(watch.buf)), false, mask, nil, &watch.ov, 0)
+	if rdErr != nil {
+		err := os.NewSyscallError("ReadDirectoryChanges", rdErr)
+		if rdErr == windows.ERROR_ACCESS_DENIED && watch.mask&provisional == 0 {
+			// Watched directory was probably removed
+			w.sendEvent(watch.path, watch.mask&sysFSDELETESELF)
+			err = nil
+		}
+		w.deleteWatch(watch)
+		w.startRead(watch)
+		return err
+	}
+	return nil
+}
+
+// readEvents reads from the I/O completion port, converts the
+// received events into Event objects and sends them via the Events channel.
+// Entry point to the I/O thread.
+func (w *Watcher) readEvents() {
+	var (
+		n   uint32
+		key uintptr
+		ov  *windows.Overlapped
+	)
+	runtime.LockOSThread()
+
+	for {
+		qErr := windows.GetQueuedCompletionStatus(w.port, &n, &key, &ov, windows.INFINITE)
+		// This error is handled after the watch == nil check below. NOTE: this
+		// seems odd, note sure if it's correct.
+
+		watch := (*watch)(unsafe.Pointer(ov))
+		if watch == nil {
+			select {
+			case ch := <-w.quit:
+				w.mu.Lock()
+				var indexes []indexMap
+				for _, index := range w.watches {
+					indexes = append(indexes, index)
+				}
+				w.mu.Unlock()
+				for _, index := range indexes {
+					for _, watch := range index {
+						w.deleteWatch(watch)
+						w.startRead(watch)
+					}
+				}
+
+				err := windows.CloseHandle(w.port)
+				if err != nil {
+					err = os.NewSyscallError("CloseHandle", err)
+				}
+				close(w.Events)
+				close(w.Errors)
+				ch <- err
+				return
+			case in := <-w.input:
+				switch in.op {
+				case opAddWatch:
+					in.reply <- w.addWatch(in.path, uint64(in.flags))
+				case opRemoveWatch:
+					in.reply <- w.remWatch(in.path)
+				}
+			default:
+			}
+			continue
+		}
+
+		switch qErr {
+		case windows.ERROR_MORE_DATA:
+			if watch == nil {
+				w.sendError(errors.New("ERROR_MORE_DATA has unexpectedly null lpOverlapped buffer"))
+			} else {
+				// The i/o succeeded but the buffer is full.
+				// In theory we should be building up a full packet.
+				// In practice we can get away with just carrying on.
+				n = uint32(unsafe.Sizeof(watch.buf))
+			}
+		case windows.ERROR_ACCESS_DENIED:
+			// Watched directory was probably removed
+			w.sendEvent(watch.path, watch.mask&sysFSDELETESELF)
+			w.deleteWatch(watch)
+			w.startRead(watch)
+			continue
+		case windows.ERROR_OPERATION_ABORTED:
+			// CancelIo was called on this handle
+			continue
+		default:
+			w.sendError(os.NewSyscallError("GetQueuedCompletionPort", qErr))
+			continue
+		case nil:
+		}
+
+		var offset uint32
+		for {
+			if n == 0 {
+				w.sendError(errors.New("short read in readEvents()"))
+				break
+			}
+
+			// Point "raw" to the event in the buffer
+			raw := (*windows.FileNotifyInformation)(unsafe.Pointer(&watch.buf[offset]))
+
+			// Create a buf that is the size of the path name
+			size := int(raw.FileNameLength / 2)
+			var buf []uint16
+			// TODO: Use unsafe.Slice in Go 1.17; https://stackoverflow.com/questions/51187973
+			sh := (*reflect.SliceHeader)(unsafe.Pointer(&buf))
+			sh.Data = uintptr(unsafe.Pointer(&raw.FileName))
+			sh.Len = size
+			sh.Cap = size
+			name := windows.UTF16ToString(buf)
+			fullname := filepath.Join(watch.path, name)
+
+			var mask uint64
+			switch raw.Action {
+			case windows.FILE_ACTION_REMOVED:
+				mask = sysFSDELETESELF
+			case windows.FILE_ACTION_MODIFIED:
+				mask = sysFSMODIFY
+			case windows.FILE_ACTION_RENAMED_OLD_NAME:
+				watch.rename = name
+			case windows.FILE_ACTION_RENAMED_NEW_NAME:
+				// Update saved path of all sub-watches.
+				old := filepath.Join(watch.path, watch.rename)
+				w.mu.Lock()
+				for _, watchMap := range w.watches {
+					for _, ww := range watchMap {
+						if strings.HasPrefix(ww.path, old) {
+							ww.path = filepath.Join(fullname, strings.TrimPrefix(ww.path, old))
+						}
+					}
+				}
+				w.mu.Unlock()
+
+				if watch.names[watch.rename] != 0 {
+					watch.names[name] |= watch.names[watch.rename]
+					delete(watch.names, watch.rename)
+					mask = sysFSMOVESELF
+				}
+			}
+
+			sendNameEvent := func() {
+				w.sendEvent(fullname, watch.names[name]&mask)
+			}
+			if raw.Action != windows.FILE_ACTION_RENAMED_NEW_NAME {
+				sendNameEvent()
+			}
+			if raw.Action == windows.FILE_ACTION_REMOVED {
+				w.sendEvent(fullname, watch.names[name]&sysFSIGNORED)
+				delete(watch.names, name)
+			}
+
+			w.sendEvent(fullname, watch.mask&w.toFSnotifyFlags(raw.Action))
+			if raw.Action == windows.FILE_ACTION_RENAMED_NEW_NAME {
+				fullname = filepath.Join(watch.path, watch.rename)
+				sendNameEvent()
+			}
+
+			// Move to the next event in the buffer
+			if raw.NextEntryOffset == 0 {
+				break
+			}
+			offset += raw.NextEntryOffset
+
+			// Error!
+			if offset >= n {
+				w.sendError(errors.New(
+					"Windows system assumed buffer larger than it is, events have likely been missed."))
+				break
+			}
+		}
+
+		if err := w.startRead(watch); err != nil {
+			w.sendError(err)
+		}
+	}
+}
+
+func (w *Watcher) toWindowsFlags(mask uint64) uint32 {
+	var m uint32
+	if mask&sysFSMODIFY != 0 {
+		m |= windows.FILE_NOTIFY_CHANGE_LAST_WRITE
+	}
+	if mask&sysFSATTRIB != 0 {
+		m |= windows.FILE_NOTIFY_CHANGE_ATTRIBUTES
+	}
+	if mask&(sysFSMOVE|sysFSCREATE|sysFSDELETE) != 0 {
+		m |= windows.FILE_NOTIFY_CHANGE_FILE_NAME | windows.FILE_NOTIFY_CHANGE_DIR_NAME
+	}
+	return m
+}
+
+func (w *Watcher) toFSnotifyFlags(action uint32) uint64 {
+	switch action {
+	case windows.FILE_ACTION_ADDED:
+		return sysFSCREATE
+	case windows.FILE_ACTION_REMOVED:
+		return sysFSDELETE
+	case windows.FILE_ACTION_MODIFIED:
+		return sysFSMODIFY
+	case windows.FILE_ACTION_RENAMED_OLD_NAME:
+		return sysFSMOVEDFROM
+	case windows.FILE_ACTION_RENAMED_NEW_NAME:
+		return sysFSMOVEDTO
+	}
+	return 0
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/backend_windows_test.go b/go_package_port/github.com/fsnotify/fsnotify/backend_windows_test.go
new file mode 100644
index 0000000..213f14c
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/backend_windows_test.go
@@ -0,0 +1,52 @@
+//go:build windows
+// +build windows
+
+package fsnotify
+
+import (
+	"fmt"
+	"path/filepath"
+	"strings"
+	"testing"
+)
+
+func TestRemoveState(t *testing.T) {
+	// TODO: the Windows backend is too confusing; needs some serious attention.
+	return
+
+	var (
+		tmp  = t.TempDir()
+		dir  = filepath.Join(tmp, "dir")
+		file = filepath.Join(dir, "file")
+	)
+	mkdir(t, dir)
+	touch(t, file)
+
+	w := newWatcher(t, tmp)
+	addWatch(t, w, tmp)
+	addWatch(t, w, file)
+
+	check := func(want int) {
+		t.Helper()
+		if len(w.watches) != want {
+			var d []string
+			for k, v := range w.watches {
+				d = append(d, fmt.Sprintf("%#v = %#v", k, v))
+			}
+			t.Errorf("unexpected number of entries in w.watches (have %d, want %d):\n%v",
+				len(w.watches), want, strings.Join(d, "\n"))
+		}
+	}
+
+	check(2)
+
+	if err := w.Remove(file); err != nil {
+		t.Fatal(err)
+	}
+	check(1)
+
+	if err := w.Remove(tmp); err != nil {
+		t.Fatal(err)
+	}
+	check(0)
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/dedup.go b/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/dedup.go
new file mode 100644
index 0000000..67269d4
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/dedup.go
@@ -0,0 +1,103 @@
+package main
+
+import (
+	"math"
+	"sync"
+	"time"
+
+	"github.com/fsnotify/fsnotify"
+)
+
+// Depending on the system, a single "write" can generate many Write events; for
+// example compiling a large Go program can generate hundreds of Write events on
+// the binary.
+//
+// The general strategy to deal with this is to wait a short time for more write
+// events, resetting the wait period for every new event.
+func dedup(paths ...string) {
+	if len(paths) < 1 {
+		exit("must specify at least one path to watch")
+	}
+
+	// Create a new watcher.
+	w, err := fsnotify.NewWatcher()
+	if err != nil {
+		exit("creating a new watcher: %s", err)
+	}
+	defer w.Close()
+
+	// Start listening for events.
+	go dedupLoop(w)
+
+	// Add all paths from the commandline.
+	for _, p := range paths {
+		err = w.Add(p)
+		if err != nil {
+			exit("%q: %s", p, err)
+		}
+	}
+
+	printTime("ready; press ^C to exit")
+	<-make(chan struct{}) // Block forever
+}
+
+func dedupLoop(w *fsnotify.Watcher) {
+	var (
+		// Wait 100ms for new events; each new event resets the timer.
+		waitFor = 100 * time.Millisecond
+
+		// Keep track of the timers, as path → timer.
+		mu     sync.Mutex
+		timers = make(map[string]*time.Timer)
+
+		// Callback we run.
+		printEvent = func(e fsnotify.Event) {
+			printTime(e.String())
+
+			// Don't need to remove the timer if you don't have a lot of files.
+			mu.Lock()
+			delete(timers, e.Name)
+			mu.Unlock()
+		}
+	)
+
+	for {
+		select {
+		// Read from Errors.
+		case err, ok := <-w.Errors:
+			if !ok { // Channel was closed (i.e. Watcher.Close() was called).
+				return
+			}
+			printTime("ERROR: %s", err)
+		// Read from Events.
+		case e, ok := <-w.Events:
+			if !ok { // Channel was closed (i.e. Watcher.Close() was called).
+				return
+			}
+
+			// We just want to watch for file creation, so ignore everything
+			// outside of Create and Write.
+			if !e.Has(fsnotify.Create) && !e.Has(fsnotify.Write) {
+				continue
+			}
+
+			// Get timer.
+			mu.Lock()
+			t, ok := timers[e.Name]
+			mu.Unlock()
+
+			// No timer yet, so create one.
+			if !ok {
+				t = time.AfterFunc(math.MaxInt64, func() { printEvent(e) })
+				t.Stop()
+
+				mu.Lock()
+				timers[e.Name] = t
+				mu.Unlock()
+			}
+
+			// Reset the timer for this path, so it will start from 100ms again.
+			t.Reset(waitFor)
+		}
+	}
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/file.go b/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/file.go
new file mode 100644
index 0000000..357e693
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/file.go
@@ -0,0 +1,85 @@
+package main
+
+import (
+	"os"
+	"path/filepath"
+
+	"github.com/fsnotify/fsnotify"
+)
+
+// Watch one or more files, but instead of watching the file directly it watches
+// the parent directory. This solves various issues where files are frequently
+// renamed, such as editors saving them.
+func file(files ...string) {
+	if len(files) < 1 {
+		exit("must specify at least one file to watch")
+	}
+
+	// Create a new watcher.
+	w, err := fsnotify.NewWatcher()
+	if err != nil {
+		exit("creating a new watcher: %s", err)
+	}
+	defer w.Close()
+
+	// Start listening for events.
+	go fileLoop(w, files)
+
+	// Add all files from the commandline.
+	for _, p := range files {
+		st, err := os.Lstat(p)
+		if err != nil {
+			exit("%s", err)
+		}
+
+		if st.IsDir() {
+			exit("%q is a directory, not a file", p)
+		}
+
+		// Watch the directory, not the file itself.
+		err = w.Add(filepath.Dir(p))
+		if err != nil {
+			exit("%q: %s", p, err)
+		}
+	}
+
+	printTime("ready; press ^C to exit")
+	<-make(chan struct{}) // Block forever
+}
+
+func fileLoop(w *fsnotify.Watcher, files []string) {
+	i := 0
+	for {
+		select {
+		// Read from Errors.
+		case err, ok := <-w.Errors:
+			if !ok { // Channel was closed (i.e. Watcher.Close() was called).
+				return
+			}
+			printTime("ERROR: %s", err)
+		// Read from Events.
+		case e, ok := <-w.Events:
+			if !ok { // Channel was closed (i.e. Watcher.Close() was called).
+				return
+			}
+
+			// Ignore files we're not interested in. Can use a
+			// map[string]struct{} if you have a lot of files, but for just a
+			// few files simply looping over a slice is faster.
+			var found bool
+			for _, f := range files {
+				if f == e.Name {
+					found = true
+				}
+			}
+			if !found {
+				continue
+			}
+
+			// Just print the event nicely aligned, and keep track how many
+			// events we've seen.
+			i++
+			printTime("%3d %s", i, e)
+		}
+	}
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/main.go b/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/main.go
new file mode 100644
index 0000000..cdd9de7
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/main.go
@@ -0,0 +1,65 @@
+// Command fsnotify provides example usage of the fsnotify library.
+package main
+
+import (
+	"fmt"
+	"os"
+	"path/filepath"
+	"time"
+)
+
+var usage = `
+fsnotify is a Go library to provide cross-platform file system notifications.
+This command serves as an example and debugging tool.
+
+https://github.com/fsnotify/fsnotify
+
+Commands:
+
+    watch [paths]  Watch the paths for changes and print the events.
+    file  [file]   Watch a single file for changes.
+    dedup [paths]  Watch the paths for changes, suppressing duplicate events.
+`[1:]
+
+func exit(format string, a ...interface{}) {
+	fmt.Fprintf(os.Stderr, filepath.Base(os.Args[0])+": "+format+"\n", a...)
+	fmt.Print("\n" + usage)
+	os.Exit(1)
+}
+
+func help() {
+	fmt.Printf("%s [command] [arguments]\n\n", filepath.Base(os.Args[0]))
+	fmt.Print(usage)
+	os.Exit(0)
+}
+
+// Print line prefixed with the time (a bit shorter than log.Print; we don't
+// really need the date and ms is useful here).
+func printTime(s string, args ...interface{}) {
+	fmt.Printf(time.Now().Format("15:04:05.0000")+" "+s+"\n", args...)
+}
+
+func main() {
+	if len(os.Args) == 1 {
+		help()
+	}
+	// Always show help if -h[elp] appears anywhere before we do anything else.
+	for _, f := range os.Args[1:] {
+		switch f {
+		case "help", "-h", "-help", "--help":
+			help()
+		}
+	}
+
+	cmd, args := os.Args[1], os.Args[2:]
+	switch cmd {
+	default:
+		exit("unknown command: %q", cmd)
+	case "watch":
+		watch(args...)
+	case "file":
+		file(args...)
+	case "dedup":
+		dedup(args...)
+	}
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/watch.go b/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/watch.go
new file mode 100644
index 0000000..046a133
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/cmd/fsnotify/watch.go
@@ -0,0 +1,56 @@
+package main
+
+import "github.com/fsnotify/fsnotify"
+
+// This is the most basic example: it prints events to the terminal as we
+// receive them.
+func watch(paths ...string) {
+	if len(paths) < 1 {
+		exit("must specify at least one path to watch")
+	}
+
+	// Create a new watcher.
+	w, err := fsnotify.NewWatcher()
+	if err != nil {
+		exit("creating a new watcher: %s", err)
+	}
+	defer w.Close()
+
+	// Start listening for events.
+	go watchLoop(w)
+
+	// Add all paths from the commandline.
+	for _, p := range paths {
+		err = w.Add(p)
+		if err != nil {
+			exit("%q: %s", p, err)
+		}
+	}
+
+	printTime("ready; press ^C to exit")
+	<-make(chan struct{}) // Block forever
+}
+
+func watchLoop(w *fsnotify.Watcher) {
+	i := 0
+	for {
+		select {
+		// Read from Errors.
+		case err, ok := <-w.Errors:
+			if !ok { // Channel was closed (i.e. Watcher.Close() was called).
+				return
+			}
+			printTime("ERROR: %s", err)
+		// Read from Events.
+		case e, ok := <-w.Events:
+			if !ok { // Channel was closed (i.e. Watcher.Close() was called).
+				return
+			}
+
+			// Just print the event nicely aligned, and keep track how many
+			// events we've seen.
+			i++
+			printTime("%3d %s", i, e)
+		}
+	}
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/fsnotify.go b/go_package_port/github.com/fsnotify/fsnotify/fsnotify.go
new file mode 100644
index 0000000..30a5bf0
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/fsnotify.go
@@ -0,0 +1,81 @@
+//go:build !plan9
+// +build !plan9
+
+// Package fsnotify provides a cross-platform interface for file system
+// notifications.
+package fsnotify
+
+import (
+	"errors"
+	"fmt"
+	"strings"
+)
+
+// Event represents a file system notification.
+type Event struct {
+	// Path to the file or directory.
+	//
+	// Paths are relative to the input; for example with Add("dir") the Name
+	// will be set to "dir/file" if you create that file, but if you use
+	// Add("/path/to/dir") it will be "/path/to/dir/file".
+	Name string
+
+	// File operation that triggered the event.
+	//
+	// This is a bitmask and some systems may send multiple operations at once.
+	// Use the Event.Has() method instead of comparing with ==.
+	Op Op
+}
+
+// Op describes a set of file operations.
+type Op uint32
+
+// The operations fsnotify can trigger; see the documentation on [Watcher] for a
+// full description, and check them with [Event.Has].
+const (
+	Create Op = 1 << iota
+	Write
+	Remove
+	Rename
+	Chmod
+)
+
+// Common errors that can be reported by a watcher
+var (
+	ErrNonExistentWatch = errors.New("can't remove non-existent watcher")
+	ErrEventOverflow    = errors.New("fsnotify queue overflow")
+)
+
+func (op Op) String() string {
+	var b strings.Builder
+	if op.Has(Create) {
+		b.WriteString("|CREATE")
+	}
+	if op.Has(Remove) {
+		b.WriteString("|REMOVE")
+	}
+	if op.Has(Write) {
+		b.WriteString("|WRITE")
+	}
+	if op.Has(Rename) {
+		b.WriteString("|RENAME")
+	}
+	if op.Has(Chmod) {
+		b.WriteString("|CHMOD")
+	}
+	if b.Len() == 0 {
+		return "[no events]"
+	}
+	return b.String()[1:]
+}
+
+// Has reports if this operation has the given operation.
+func (o Op) Has(h Op) bool { return o&h == h }
+
+// Has reports if this event has the given operation.
+func (e Event) Has(op Op) bool { return e.Op.Has(op) }
+
+// String returns a string representation of the event with their path.
+func (e Event) String() string {
+	return fmt.Sprintf("%-13s %q", e.Op.String(), e.Name)
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/fsnotify_test.go b/go_package_port/github.com/fsnotify/fsnotify/fsnotify_test.go
new file mode 100644
index 0000000..d8c7f5e
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/fsnotify_test.go
@@ -0,0 +1,1205 @@
+//go:build !plan9 && !solaris
+// +build !plan9,!solaris
+
+package fsnotify
+
+import (
+	"errors"
+	"fmt"
+	"os"
+	"path/filepath"
+	"reflect"
+	"runtime"
+	"sort"
+	"strings"
+	"sync/atomic"
+	"testing"
+	"time"
+
+	"github.com/fsnotify/fsnotify/internal"
+)
+
+// Set soft open file limit to the maximum; on e.g. OpenBSD it's 512/1024.
+//
+// Go 1.19 will always do this when the os package is imported.
+//
+// https://go-review.googlesource.com/c/go/+/393354/
+func init() {
+	internal.SetRlimit()
+}
+
+func TestWatch(t *testing.T) {
+	tests := []testCase{
+		{"multiple creates", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+			addWatch(t, w, tmp)
+
+			cat(t, "data", file)
+			rm(t, file)
+
+			touch(t, file)       // Recreate the file
+			cat(t, "data", file) // Modify
+			cat(t, "data", file) // Modify
+		}, `
+			create  /file
+			write   /file
+			remove  /file
+			create  /file
+			write   /file
+			write   /file
+		`},
+
+		{"dir only", func(t *testing.T, w *Watcher, tmp string) {
+			beforeWatch := filepath.Join(tmp, "beforewatch")
+			file := filepath.Join(tmp, "file")
+
+			touch(t, beforeWatch)
+			addWatch(t, w, tmp)
+
+			cat(t, "data", file)
+			rm(t, file)
+			rm(t, beforeWatch)
+		}, `
+			create /file
+			write  /file
+			remove /file
+			remove /beforewatch
+		`},
+
+		{"subdir", func(t *testing.T, w *Watcher, tmp string) {
+			addWatch(t, w, tmp)
+
+			file := filepath.Join(tmp, "file")
+			dir := filepath.Join(tmp, "sub")
+			dirfile := filepath.Join(tmp, "sub/file2")
+
+			mkdir(t, dir)     // Create sub-directory
+			touch(t, file)    // Create a file
+			touch(t, dirfile) // Create a file (Should not see this! we are not watching subdir)
+			time.Sleep(200 * time.Millisecond)
+			rmAll(t, dir) // Make sure receive deletes for both file and sub-directory
+			rm(t, file)
+		}, `
+			create /sub
+			create /file
+			remove /sub
+			remove /file
+
+			# TODO: not sure why the REMOVE /sub is dropped.
+			dragonfly:
+				create    /sub
+				create    /file
+				remove    /file
+
+			# Windows includes a write for the /sub dir too, two of them even(?)
+			windows:
+				create /sub
+				create /file
+				write  /sub
+				write  /sub
+				remove /sub
+				remove /file
+		`},
+
+		{"file in directory is not readable", func(t *testing.T, w *Watcher, tmp string) {
+			if runtime.GOOS == "windows" {
+				t.Skip("attributes don't work on Windows")
+			}
+
+			touch(t, tmp, "file-unreadable")
+			chmod(t, 0, tmp, "file-unreadable")
+			touch(t, tmp, "file")
+			addWatch(t, w, tmp)
+
+			cat(t, "hello", tmp, "file")
+			rm(t, tmp, "file")
+			rm(t, tmp, "file-unreadable")
+		}, `
+			WRITE     "/file"
+			REMOVE    "/file"
+			REMOVE    "/file-unreadable"
+
+			# We never set up a watcher on the unreadable file, so we don't get
+			# the REMOVE.
+			kqueue:
+				WRITE    "/file"
+				REMOVE   "/file"
+		`},
+
+		{"watch same dir twice", func(t *testing.T, w *Watcher, tmp string) {
+			addWatch(t, w, tmp)
+			addWatch(t, w, tmp)
+
+			touch(t, tmp, "file")
+			cat(t, "hello", tmp, "file")
+			rm(t, tmp, "file")
+			mkdir(t, tmp, "dir")
+		}, `
+			create   /file
+			write    /file
+			remove   /file
+			create   /dir
+		`},
+
+		{"watch same file twice", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+			touch(t, file)
+
+			addWatch(t, w, file)
+			addWatch(t, w, file)
+
+			cat(t, "hello", tmp, "file")
+		}, `
+			write    /file
+		`},
+
+		{"watch a symlink to a file", func(t *testing.T, w *Watcher, tmp string) {
+			if runtime.GOOS == "darwin" {
+				// TODO
+				// WRITE "/private/var/folders/.../TestWatchwatch_a_symlink_to_a_file183391030/001/file"
+				// Pretty sure this is caused by the broken symlink-follow
+				// behaviour too.
+				t.Skip("broken on macOS")
+			}
+
+			file := filepath.Join(tmp, "file")
+			link := filepath.Join(tmp, "link")
+			touch(t, file)
+			symlink(t, file, link)
+			addWatch(t, w, link)
+
+			cat(t, "hello", file)
+		}, `
+			write    /link
+
+			# TODO: Symlinks followed on kqueue; it shouldn't do this, but I'm
+			# afraid changing it will break stuff. See #227, #390
+			kqueue:
+				write    /file
+
+			# TODO: see if we can fix this.
+			windows:
+				empty
+		`},
+
+		{"watch a symlink to a dir", func(t *testing.T, w *Watcher, tmp string) {
+			if runtime.GOOS == "darwin" {
+				// TODO
+				// CREATE "/private/var/.../TestWatchwatch_a_symlink_to_a_dir2551725268/001/dir/file"
+				// Pretty sure this is caused by the broken symlink-follow
+				// behaviour too.
+
+				t.Skip("broken on macOS")
+			}
+
+			dir := filepath.Join(tmp, "dir")
+			link := filepath.Join(tmp, "link")
+			mkdir(t, dir)
+			symlink(t, dir, link)
+			addWatch(t, w, link)
+
+			touch(t, dir, "file")
+		}, `
+			create    /link/file
+
+			# TODO: Symlinks followed on kqueue; it shouldn't do this, but I'm
+			# afraid changing it will break stuff. See #227, #390
+			kqueue:
+				create /dir/file
+		`},
+	}
+
+	for _, tt := range tests {
+		tt := tt
+		tt.run(t)
+	}
+}
+
+func TestWatchCreate(t *testing.T) {
+	tests := []testCase{
+		// Files
+		{"create empty file", func(t *testing.T, w *Watcher, tmp string) {
+			addWatch(t, w, tmp)
+			touch(t, tmp, "file")
+		}, `
+			create  /file
+		`},
+		{"create file with data", func(t *testing.T, w *Watcher, tmp string) {
+			addWatch(t, w, tmp)
+			cat(t, "data", tmp, "file")
+		}, `
+			create  /file
+			write   /file
+		`},
+
+		// Directories
+		{"create new directory", func(t *testing.T, w *Watcher, tmp string) {
+			addWatch(t, w, tmp)
+			mkdir(t, tmp, "dir")
+		}, `
+			create  /dir
+		`},
+
+		// Links
+		{"create new symlink to file", func(t *testing.T, w *Watcher, tmp string) {
+			touch(t, tmp, "file")
+			addWatch(t, w, tmp)
+			symlink(t, filepath.Join(tmp, "file"), tmp, "link")
+		}, `
+			create  /link
+
+			windows:
+				create   /link
+				write    /link
+		`},
+		{"create new symlink to directory", func(t *testing.T, w *Watcher, tmp string) {
+			addWatch(t, w, tmp)
+			symlink(t, tmp, tmp, "link")
+		}, `
+			create  /link
+
+			windows:
+				create  /link
+				write  /link
+		`},
+
+		// FIFO
+		{"create new named pipe", func(t *testing.T, w *Watcher, tmp string) {
+			if runtime.GOOS == "windows" {
+				t.Skip("no named pipes on windows")
+			}
+			touch(t, tmp, "file")
+			addWatch(t, w, tmp)
+			mkfifo(t, tmp, "fifo")
+		}, `
+			create  /fifo
+		`},
+		// Device node
+		{"create new device node pipe", func(t *testing.T, w *Watcher, tmp string) {
+			if runtime.GOOS == "windows" {
+				t.Skip("no device nodes on windows")
+			}
+			if isKqueue() {
+				t.Skip("needs root on BSD")
+			}
+			touch(t, tmp, "file")
+			addWatch(t, w, tmp)
+
+			mknod(t, 0, tmp, "dev")
+		}, `
+			create  /dev
+		`},
+	}
+	for _, tt := range tests {
+		tt := tt
+		tt.run(t)
+	}
+}
+
+func TestWatchWrite(t *testing.T) {
+	tests := []testCase{
+		// Files
+		{"truncate file", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+			cat(t, "data", file)
+			addWatch(t, w, tmp)
+
+			fp, err := os.Create(file)
+			if err != nil {
+				t.Fatal(err)
+			}
+			if err := fp.Sync(); err != nil {
+				t.Fatal(err)
+			}
+			eventSeparator()
+			if _, err := fp.Write([]byte("X")); err != nil {
+				t.Fatal(err)
+			}
+			if err := fp.Close(); err != nil {
+				t.Fatal(err)
+			}
+		}, `
+			write  /file  # truncate
+			write  /file  # write
+
+			# Truncate is chmod on kqueue, except NetBSD
+			netbsd:
+				write  /file
+			kqueue:
+				chmod     /file
+				write     /file
+		`},
+
+		{"multiple writes to a file", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+			cat(t, "data", file)
+			addWatch(t, w, tmp)
+
+			fp, err := os.OpenFile(file, os.O_RDWR, 0)
+			if err != nil {
+				t.Fatal(err)
+			}
+			if _, err := fp.Write([]byte("X")); err != nil {
+				t.Fatal(err)
+			}
+			if err := fp.Sync(); err != nil {
+				t.Fatal(err)
+			}
+			eventSeparator()
+			if _, err := fp.Write([]byte("Y")); err != nil {
+				t.Fatal(err)
+			}
+			if err := fp.Close(); err != nil {
+				t.Fatal(err)
+			}
+		}, `
+			write  /file  # write X
+			write  /file  # write Y
+		`},
+	}
+	for _, tt := range tests {
+		tt := tt
+		tt.run(t)
+	}
+}
+
+func TestWatchRename(t *testing.T) {
+	tests := []testCase{
+		{"rename file in watched dir", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+			cat(t, "asd", file)
+
+			addWatch(t, w, tmp)
+			mv(t, file, tmp, "renamed")
+		}, `
+			rename /file
+			create /renamed
+		`},
+
+		{"rename from unwatched dir", func(t *testing.T, w *Watcher, tmp string) {
+			unwatched := t.TempDir()
+
+			addWatch(t, w, tmp)
+			touch(t, unwatched, "file")
+			mv(t, filepath.Join(unwatched, "file"), tmp, "file")
+		}, `
+			create /file
+		`},
+
+		{"rename to unwatched dir", func(t *testing.T, w *Watcher, tmp string) {
+			if runtime.GOOS == "netbsd" && isCI() {
+				t.Skip("fails in CI; see #488")
+			}
+
+			unwatched := t.TempDir()
+			file := filepath.Join(tmp, "file")
+			renamed := filepath.Join(unwatched, "renamed")
+
+			addWatch(t, w, tmp)
+
+			cat(t, "data", file)
+			mv(t, file, renamed)
+			cat(t, "data", renamed) // Modify the file outside of the watched dir
+			touch(t, file)          // Recreate the file that was moved
+		}, `
+			create /file # cat data >file
+			write  /file # ^
+			rename /file # mv file ../renamed
+			create /file # touch file
+
+			# Windows has REMOVE /file, rather than CREATE /file
+			windows:
+				create   /file
+				write    /file
+				remove   /file
+				create   /file
+		`},
+
+		{"rename overwriting existing file", func(t *testing.T, w *Watcher, tmp string) {
+			unwatched := t.TempDir()
+			file := filepath.Join(unwatched, "file")
+
+			touch(t, tmp, "renamed")
+			touch(t, file)
+
+			addWatch(t, w, tmp)
+			mv(t, file, tmp, "renamed")
+		}, `
+			# TODO: this should really be RENAME.
+			remove /renamed
+			create /renamed
+
+			# No remove event for inotify; inotify just sends MOVE_SELF.
+			linux:
+				create /renamed
+
+			# TODO: this is broken.
+			dragonfly:
+				REMOVE|WRITE         "/"
+		`},
+
+		{"rename watched directory", func(t *testing.T, w *Watcher, tmp string) {
+			addWatch(t, w, tmp)
+
+			dir := filepath.Join(tmp, "dir")
+			mkdir(t, dir)
+			addWatch(t, w, dir)
+
+			mv(t, dir, tmp, "dir-renamed")
+			touch(t, tmp, "dir-renamed/file")
+		}, `
+			CREATE   "/dir"           # mkdir
+			RENAME   "/dir"           # mv
+			CREATE   "/dir-renamed"
+			RENAME   "/dir"
+			CREATE   "/dir/file"      # touch
+
+			windows:
+				CREATE       "/dir"                 # mkdir
+				RENAME       "/dir"                 # mv
+				CREATE       "/dir-renamed"
+				CREATE       "/dir-renamed/file"    # touch
+
+			# TODO: no results for the touch; this is probably a bug; windows
+			# was fixed in #370.
+			kqueue:
+				CREATE               "/dir"           # mkdir
+				CREATE               "/dir-renamed"   # mv
+				REMOVE|RENAME        "/dir"
+		`},
+
+		{"rename watched file", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+			rename := filepath.Join(tmp, "rename-one")
+			touch(t, file)
+
+			addWatch(t, w, file)
+
+			mv(t, file, rename)
+			mv(t, rename, tmp, "rename-two")
+		}, `
+			# TODO: this should update the path. And even then, not clear what
+			# go renamed to what.
+			rename /file  # mv file rename
+			rename /file  # mv rename rename-two
+
+			# TODO: seems to lose the watch?
+			kqueue:
+				rename     /file
+
+			# It's actually more correct on Windows.
+			windows:
+				rename     /file
+				rename     /rename-one
+		`},
+
+		{"re-add renamed file", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+			rename := filepath.Join(tmp, "rename")
+			touch(t, file)
+
+			addWatch(t, w, file)
+
+			mv(t, file, rename)
+			touch(t, file)
+			addWatch(t, w, file)
+			cat(t, "hello", rename)
+			cat(t, "hello", file)
+		}, `
+			rename /file    # mv file rename
+			write  /rename  # cat hello >rename
+			write  /file    # cat hello >file
+
+			# TODO: wrong.
+			linux:
+			    RENAME     "/file"
+			    WRITE      "/file"
+			    WRITE      ""
+
+			# TODO: wrong.
+			kqueue:
+			   RENAME      "/file"
+			   WRITE       "/file"
+		`},
+	}
+
+	for _, tt := range tests {
+		tt := tt
+		tt.run(t)
+	}
+}
+
+func TestWatchSymlink(t *testing.T) {
+	tests := []testCase{
+		{"create unresolvable symlink", func(t *testing.T, w *Watcher, tmp string) {
+			addWatch(t, w, tmp)
+
+			symlink(t, filepath.Join(tmp, "target"), tmp, "link")
+		}, `
+			create /link
+
+			windows:
+				create    /link
+				write     /link
+
+			# No events at all on Dragonfly
+			# TODO: should fix this.
+			dragonfly:
+				empty
+		`},
+
+		{"cyclic symlink", func(t *testing.T, w *Watcher, tmp string) {
+			if runtime.GOOS == "darwin" {
+				// This test is borked on macOS; it reports events outside the
+				// watched directory:
+				//
+				//   create "/private/.../testwatchsymlinkcyclic_symlink3681444267/001/link"
+				//   create "/link"
+				//   write  "/link"
+				//   write  "/private/.../testwatchsymlinkcyclic_symlink3681444267/001/link"
+				//
+				// kqueue.go does a lot of weird things with symlinks that I
+				// don't think are necessarily correct, but need to test a bit
+				// more.
+				t.Skip()
+			}
+
+			symlink(t, ".", tmp, "link")
+			addWatch(t, w, tmp)
+			rm(t, tmp, "link")
+			cat(t, "foo", tmp, "link")
+
+		}, `
+			write  /link
+			create /link
+
+			linux, windows:
+				remove    /link
+				create    /link
+				write     /link
+		`},
+	}
+
+	for _, tt := range tests {
+		tt := tt
+		tt.run(t)
+	}
+}
+
+func TestWatchAttrib(t *testing.T) {
+	if runtime.GOOS == "windows" {
+		t.Skip("attributes don't work on Windows")
+	}
+
+	tests := []testCase{
+		{"chmod", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+
+			cat(t, "data", file)
+			addWatch(t, w, file)
+			chmod(t, 0o700, file)
+		}, `
+			CHMOD   "/file"
+		`},
+
+		{"write does not trigger CHMOD", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+
+			cat(t, "data", file)
+			addWatch(t, w, file)
+			chmod(t, 0o700, file)
+
+			cat(t, "more data", file)
+		}, `
+			CHMOD   "/file"
+			WRITE   "/file"
+		`},
+
+		{"chmod after write", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+
+			cat(t, "data", file)
+			addWatch(t, w, file)
+			chmod(t, 0o700, file)
+			cat(t, "more data", file)
+			chmod(t, 0o600, file)
+		}, `
+			CHMOD   "/file"
+			WRITE   "/file"
+			CHMOD   "/file"
+		`},
+	}
+
+	for _, tt := range tests {
+		tt := tt
+		tt.run(t)
+	}
+}
+
+func TestWatchRm(t *testing.T) {
+	tests := []testCase{
+		{"remove watched file", func(t *testing.T, w *Watcher, tmp string) {
+			file := filepath.Join(tmp, "file")
+			touch(t, file)
+
+			addWatch(t, w, file)
+			rm(t, file)
+		}, `
+			REMOVE   "/file"
+
+			# unlink always emits a CHMOD on Linux.
+			linux:
+				CHMOD    "/file"
+				REMOVE   "/file"
+		`},
+
+		{"remove watched file with open fd", func(t *testing.T, w *Watcher, tmp string) {
+			if runtime.GOOS == "windows" {
+				t.Skip("Windows hard-locks open files so this will never work")
+			}
+
+			file := filepath.Join(tmp, "file")
+			touch(t, file)
+
+			// Intentionally don't close the descriptor here so it stays around.
+			_, err := os.Open(file)
+			if err != nil {
+				t.Fatal(err)
+			}
+
+			addWatch(t, w, file)
+			rm(t, file)
+		}, `
+			REMOVE   "/file"
+
+			# inotify will just emit a CHMOD for the unlink, but won't actually
+			# emit a REMOVE until the descriptor is closed. Bit odd, but not much
+			# we can do about it. The REMOVE is tested in TestInotifyDeleteOpenFile()
+			linux:
+				CHMOD    "/file"
+		`},
+
+		{"remove watched directory", func(t *testing.T, w *Watcher, tmp string) {
+			if runtime.GOOS == "openbsd" || runtime.GOOS == "netbsd" {
+				t.Skip("behaviour is inconsistent on OpenBSD and NetBSD, and this test is flaky")
+			}
+
+			file := filepath.Join(tmp, "file")
+
+			touch(t, file)
+			addWatch(t, w, tmp)
+			rmAll(t, tmp)
+		}, `
+			# OpenBSD, NetBSD
+			remove             /file
+			remove|write       /
+
+			freebsd:
+				remove|write   "/"
+				remove         ""
+				create         "."
+
+			darwin:
+				remove         /file
+				remove|write   /
+			linux:
+				remove         /file
+				remove         /
+			windows:
+				remove         /file
+				remove         /
+		`},
+	}
+
+	for _, tt := range tests {
+		tt := tt
+		tt.run(t)
+	}
+}
+
+func TestClose(t *testing.T) {
+	chanClosed := func(t *testing.T, w *Watcher) {
+		t.Helper()
+
+		// Need a small sleep as Close() on kqueue does all sorts of things,
+		// which may take a little bit.
+		switch runtime.GOOS {
+		case "freebsd", "openbsd", "netbsd", "dragonfly", "darwin":
+			time.Sleep(5 * time.Millisecond)
+		}
+
+		select {
+		default:
+			t.Fatal("blocking on Events")
+		case _, ok := <-w.Events:
+			if ok {
+				t.Fatal("Events not closed")
+			}
+		}
+		select {
+		default:
+			t.Fatal("blocking on Errors")
+		case _, ok := <-w.Errors:
+			if ok {
+				t.Fatal("Errors not closed")
+			}
+		}
+	}
+
+	t.Run("close", func(t *testing.T) {
+		t.Parallel()
+
+		w := newWatcher(t)
+		if err := w.Close(); err != nil {
+			t.Fatal(err)
+		}
+		chanClosed(t, w)
+
+		var done int32
+		go func() {
+			w.Close()
+			atomic.StoreInt32(&done, 1)
+		}()
+
+		eventSeparator()
+		if atomic.LoadInt32(&done) == 0 {
+			t.Fatal("double Close() test failed: second Close() call didn't return")
+		}
+
+		if err := w.Add(t.TempDir()); err == nil {
+			t.Fatal("expected error on Watch() after Close(), got nil")
+		}
+	})
+
+	// Make sure that Close() works even when the Events channel isn't being
+	// read.
+	t.Run("events not read", func(t *testing.T) {
+		t.Parallel()
+
+		tmp := t.TempDir()
+		w := newWatcher(t, tmp)
+
+		touch(t, tmp, "file")
+		rm(t, tmp, "file")
+		if err := w.Close(); err != nil {
+			t.Fatal(err)
+		}
+
+		// TODO: windows backend doesn't work well here; can't easily fix it.
+		//       Need to rewrite things a bit.
+		if runtime.GOOS != "windows" {
+			chanClosed(t, w)
+		}
+	})
+
+	// Make sure that calling Close() while REMOVE events are emitted doesn't race.
+	t.Run("close while removing files", func(t *testing.T) {
+		t.Parallel()
+		tmp := t.TempDir()
+
+		files := make([]string, 0, 200)
+		for i := 0; i < 200; i++ {
+			f := filepath.Join(tmp, fmt.Sprintf("file-%03d", i))
+			touch(t, f, noWait)
+			files = append(files, f)
+		}
+
+		w := newWatcher(t, tmp)
+
+		startC, stopC, errC := make(chan struct{}), make(chan struct{}), make(chan error)
+		go func() {
+			for {
+				select {
+				case <-w.Errors:
+				case <-w.Events:
+				case <-stopC:
+					return
+				}
+			}
+		}()
+		rmDone := make(chan struct{})
+		go func() {
+			<-startC
+			for _, f := range files {
+				rm(t, f, noWait)
+			}
+			rmDone <- struct{}{}
+		}()
+		go func() {
+			<-startC
+			errC <- w.Close()
+		}()
+		close(startC)
+		defer close(stopC)
+		if err := <-errC; err != nil {
+			t.Fatal(err)
+		}
+
+		<-rmDone
+	})
+
+	// Make sure Close() doesn't race when called more than once; hard to write
+	// a good reproducible test for this, but running it 150 times seems to
+	// reproduce it in ~75% of cases and isn't too slow (~0.06s on my system).
+	t.Run("double close", func(t *testing.T) {
+		t.Parallel()
+
+		for i := 0; i < 150; i++ {
+			w, err := NewWatcher()
+			if err != nil {
+				if strings.Contains(err.Error(), "too many") { // syscall.EMFILE
+					time.Sleep(100 * time.Millisecond)
+					continue
+				}
+				t.Fatal(err)
+			}
+			go w.Close()
+			go w.Close()
+			go w.Close()
+		}
+	})
+
+	t.Run("closes channels after read", func(t *testing.T) {
+		if runtime.GOOS == "netbsd" {
+			t.Skip("flaky") // TODO
+		}
+
+		t.Parallel()
+
+		tmp := t.TempDir()
+
+		w := newCollector(t, tmp)
+		w.collect(t)
+		touch(t, tmp, "qwe")
+		touch(t, tmp, "asd")
+
+		if err := w.w.Close(); err != nil {
+			t.Fatal(err)
+		}
+
+		chanClosed(t, w.w)
+	})
+}
+
+func TestAdd(t *testing.T) {
+	t.Run("permission denied", func(t *testing.T) {
+		if runtime.GOOS == "windows" {
+			t.Skip("attributes don't work on Windows")
+		}
+
+		t.Parallel()
+
+		tmp := t.TempDir()
+		dir := filepath.Join(tmp, "dir-unreadable")
+		mkdir(t, dir)
+		touch(t, dir, "/file")
+		chmod(t, 0, dir)
+
+		w := newWatcher(t)
+		defer func() {
+			w.Close()
+			chmod(t, 0o755, dir) // Make TempDir() cleanup work
+		}()
+		err := w.Add(dir)
+		if err == nil {
+			t.Fatal("error is nil")
+		}
+		if !errors.Is(err, internal.UnixEACCES) {
+			t.Errorf("not unix.EACCESS: %T %#[1]v", err)
+		}
+		if !errors.Is(err, internal.SyscallEACCES) {
+			t.Errorf("not syscall.EACCESS: %T %#[1]v", err)
+		}
+	})
+}
+
+// TODO: should also check internal state is correct/cleaned up; e.g. no
+//       left-over file descriptors or whatnot.
+func TestRemove(t *testing.T) {
+	t.Run("works", func(t *testing.T) {
+		t.Parallel()
+
+		tmp := t.TempDir()
+		touch(t, tmp, "file")
+
+		w := newCollector(t)
+		w.collect(t)
+		addWatch(t, w.w, tmp)
+		if err := w.w.Remove(tmp); err != nil {
+			t.Fatal(err)
+		}
+
+		time.Sleep(200 * time.Millisecond)
+		cat(t, "data", tmp, "file")
+		chmod(t, 0o700, tmp, "file")
+
+		have := w.stop(t)
+		if len(have) > 0 {
+			t.Errorf("received events; expected none:\n%s", have)
+		}
+	})
+
+	t.Run("remove same dir twice", func(t *testing.T) {
+		t.Parallel()
+
+		tmp := t.TempDir()
+
+		touch(t, tmp, "file")
+
+		w := newWatcher(t)
+		defer w.Close()
+
+		addWatch(t, w, tmp)
+
+		if err := w.Remove(tmp); err != nil {
+			t.Fatal(err)
+		}
+		err := w.Remove(tmp)
+		if err == nil {
+			t.Fatal("no error")
+		}
+		if !errors.Is(err, ErrNonExistentWatch) {
+			t.Fatalf("wrong error: %T", err)
+		}
+	})
+
+	// Make sure that concurrent calls to Remove() don't race.
+	t.Run("no race", func(t *testing.T) {
+		t.Parallel()
+
+		tmp := t.TempDir()
+		touch(t, tmp, "file")
+
+		for i := 0; i < 10; i++ {
+			w := newWatcher(t)
+			defer w.Close()
+			addWatch(t, w, tmp)
+
+			done := make(chan struct{})
+			go func() {
+				defer func() { done <- struct{}{} }()
+				w.Remove(tmp)
+			}()
+			go func() {
+				defer func() { done <- struct{}{} }()
+				w.Remove(tmp)
+			}()
+			<-done
+			<-done
+			w.Close()
+		}
+	})
+}
+
+func TestEventString(t *testing.T) {
+	tests := []struct {
+		in   Event
+		want string
+	}{
+		{Event{}, `[no events]   ""`},
+		{Event{"/file", 0}, `[no events]   "/file"`},
+
+		{Event{"/file", Chmod | Create},
+			`CREATE|CHMOD  "/file"`},
+		{Event{"/file", Rename},
+			`RENAME        "/file"`},
+		{Event{"/file", Remove},
+			`REMOVE        "/file"`},
+		{Event{"/file", Write | Chmod},
+			`WRITE|CHMOD   "/file"`},
+	}
+
+	for _, tt := range tests {
+		t.Run("", func(t *testing.T) {
+			have := tt.in.String()
+			if have != tt.want {
+				t.Errorf("\nhave: %q\nwant: %q", have, tt.want)
+			}
+		})
+	}
+}
+
+func isKqueue() bool {
+	switch runtime.GOOS {
+	case "linux", "windows":
+		return false
+	}
+	return true
+}
+
+// Verify the watcher can keep up with file creations/deletions when under load.
+func TestWatchStress(t *testing.T) {
+	// On NetBSD ioutil.ReadDir in sendDirectoryChangeEvents() returns EINVAL
+	// ~80% of the time:
+	//
+	//    readdirent /tmp/TestWatchStress3584363325/001: invalid argument
+	//
+	// This ends up calling getdents(), the manpage says:
+	//
+	// [EINVAL]  A directory was being read on NFS, but it was modified on the
+	//           server while it was being read.
+	//
+	// Which is, eh, odd? Maybe I read the code wrong and it's calling another
+	// function too(?)
+	//
+	// Because this happens on the Errors channel we can't "skip" it like with
+	// other kqueue platorms, so just skip the entire test for now.
+	//
+	// TODO: fix this.
+	if runtime.GOOS == "netbsd" {
+		t.Skip("broken on NetBSD")
+	}
+
+	Errorf := func(t *testing.T, msg string, args ...interface{}) {
+		if !isKqueue() {
+			t.Errorf(msg, args...)
+			return
+		}
+
+		// On kqueue platforms it doesn't seem to sync properly; see comment for
+		// the sleep below.
+		//
+		// TODO: fix this.
+		t.Logf(msg, args...)
+		t.Skip("flaky on kqueue; allowed to fail")
+	}
+
+	tmp := t.TempDir()
+	w := newCollector(t, tmp)
+	w.collect(t)
+
+	fmtNum := func(n int) string {
+		s := fmt.Sprintf("%09d", n)
+		return s[:3] + "_" + s[3:6] + "_" + s[6:]
+	}
+
+	var (
+		numFiles = 1_500_000
+		runFor   = 30 * time.Second
+	)
+	if testing.Short() {
+		runFor = time.Second
+	}
+
+	// Otherwise platforms with low limits such as as OpenBSD and NetBSD will
+	// fail, since every watched file uses a file descriptor. Need superuser
+	// permissions and twiddling with /etc/login.conf to adjust them, so we
+	// can't "just increase it".
+	if isKqueue() && uint64(numFiles) > internal.Maxfiles() {
+		numFiles = int(internal.Maxfiles()) - 100
+		t.Logf("limiting files to %d due to max open files limit", numFiles)
+	}
+
+	var (
+		prefix = "xyz-prefix-"
+		done   = make(chan struct{})
+	)
+	// testing.Short()
+	go func() {
+		numFiles = createFiles(t, tmp, prefix, numFiles, runFor)
+
+		// TODO: this shouldn't be needed; and if this is too short some very
+		//       odd events happen:
+		//
+		//         fsnotify_test.go:837: saw 42 unexpected events:
+		//             REMOVE               ""
+		//             CREATE               "."
+		//             REMOVE               ""
+		//             CREATE               "."
+		//             REMOVE               ""
+		//             ...
+		//
+		//         fsnotify_test.go:848: expected the following 3175 events, but didn't see them (showing first 100 only)
+		//             REMOVE               "/xyz-prefix-000_015_080"
+		//             REMOVE               "/xyz-prefix-000_014_536"
+		//             CREATE               "/xyz-prefix-000_015_416"
+		//             CREATE               "/xyz-prefix-000_015_406"
+		//             ...
+		//
+		// Should really add a Sync() method which processes all outstanding
+		// events.
+		if isKqueue() {
+			time.Sleep(1000 * time.Millisecond)
+			if !testing.Short() {
+				time.Sleep(1000 * time.Millisecond)
+			}
+		}
+
+		for i := 0; i < numFiles; i++ {
+			rm(t, tmp, prefix+fmtNum(i), noWait)
+		}
+		close(done)
+	}()
+	<-done
+
+	have := w.stopWait(t, 10*time.Second)
+
+	// Do some work to get reasonably nice error reports; what cmpEvents() gives
+	// us is nice if you have just a few events, but with thousands it qiuckly
+	// gets unwieldy.
+
+	want := make(map[Event]struct{})
+	for i := 0; i < numFiles; i++ {
+		n := "/" + prefix + fmtNum(i)
+		want[Event{Name: n, Op: Remove}] = struct{}{}
+		want[Event{Name: n, Op: Create}] = struct{}{}
+	}
+
+	var extra Events
+	for _, h := range have {
+		h.Name = filepath.ToSlash(strings.TrimPrefix(h.Name, tmp))
+		_, ok := want[h]
+		if ok {
+			delete(want, h)
+		} else {
+			extra = append(extra, h)
+		}
+	}
+
+	if len(extra) > 0 {
+		if len(extra) > 100 {
+			Errorf(t, "saw %d unexpected events (showing first 100 only):\n%s", len(extra), extra[:100])
+		} else {
+			Errorf(t, "saw %d unexpected events:\n%s", len(extra), extra)
+		}
+	}
+
+	if len(want) != 0 {
+		wantE := make(Events, 0, len(want))
+		for k := range want {
+			wantE = append(wantE, k)
+		}
+
+		if len(wantE) > 100 {
+			Errorf(t, "expected the following %d events, but didn't see them (showing first 100 only)\n%s", len(wantE), wantE[:100])
+		} else {
+			Errorf(t, "expected the following %d events, but didn't see them\n%s", len(wantE), wantE)
+		}
+	}
+}
+
+func TestWatchList(t *testing.T) {
+	if runtime.GOOS == "windows" {
+		// TODO: probably should I guess...
+		t.Skip("WatchList has always beek broken on Windows and I don't feel like fixing it")
+	}
+
+	t.Parallel()
+
+	tmp := t.TempDir()
+	file := filepath.Join(tmp, "file")
+	other := filepath.Join(tmp, "other")
+
+	touch(t, file)
+	touch(t, other)
+
+	w := newWatcher(t, file, tmp)
+	defer w.Close()
+
+	have := w.WatchList()
+	sort.Strings(have)
+	want := []string{tmp, file}
+	if !reflect.DeepEqual(have, want) {
+		t.Errorf("\nhave: %s\nwant: %s", have, want)
+	}
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/go.mod b/go_package_port/github.com/fsnotify/fsnotify/go.mod
new file mode 100644
index 0000000..220ed74
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/go.mod
@@ -0,0 +1,10 @@
+module github.com/fsnotify/fsnotify
+
+go 1.16
+
+require golang.org/x/sys v0.0.0-20220908164124-27713097b956
+
+retract (
+	v1.5.3 // Published an incorrect branch accidentally https://github.com/fsnotify/fsnotify/issues/445
+	v1.5.0 // Contains symlink regression https://github.com/fsnotify/fsnotify/pull/394
+)
diff --git a/go_package_port/github.com/fsnotify/fsnotify/go.sum b/go_package_port/github.com/fsnotify/fsnotify/go.sum
new file mode 100644
index 0000000..64605d7
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/go.sum
@@ -0,0 +1,2 @@
+golang.org/x/sys v0.0.0-20220908164124-27713097b956 h1:XeJjHH1KiLpKGb6lvMiksZ9l0fVUh+AmGcm0nOMEBOY=
+golang.org/x/sys v0.0.0-20220908164124-27713097b956/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
diff --git a/go_package_port/github.com/fsnotify/fsnotify/helpers_test.go b/go_package_port/github.com/fsnotify/fsnotify/helpers_test.go
new file mode 100644
index 0000000..ec1c3bc
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/helpers_test.go
@@ -0,0 +1,563 @@
+package fsnotify
+
+import (
+	"fmt"
+	"io/fs"
+	"os"
+	"path/filepath"
+	"runtime"
+	"sort"
+	"strings"
+	"sync"
+	"testing"
+	"time"
+
+	"github.com/fsnotify/fsnotify/internal"
+)
+
+type testCase struct {
+	name string
+	ops  func(*testing.T, *Watcher, string)
+	want string
+}
+
+func (tt testCase) run(t *testing.T) {
+	t.Helper()
+	t.Run(tt.name, func(t *testing.T) {
+		t.Helper()
+		t.Parallel()
+		tmp := t.TempDir()
+
+		w := newCollector(t)
+		w.collect(t)
+
+		tt.ops(t, w.w, tmp)
+
+		cmpEvents(t, tmp, w.stop(t), newEvents(t, tt.want))
+	})
+}
+
+// We wait a little bit after most commands; gives the system some time to sync
+// things and makes things more consistent across platforms.
+func eventSeparator() { time.Sleep(50 * time.Millisecond) }
+func waitForEvents()  { time.Sleep(500 * time.Millisecond) }
+
+// newWatcher initializes an fsnotify Watcher instance.
+func newWatcher(t *testing.T, add ...string) *Watcher {
+	t.Helper()
+	w, err := NewWatcher()
+	if err != nil {
+		t.Fatalf("newWatcher: %s", err)
+	}
+	for _, a := range add {
+		err := w.Add(a)
+		if err != nil {
+			t.Fatalf("newWatcher: add %q: %s", a, err)
+		}
+	}
+	return w
+}
+
+// addWatch adds a watch for a directory
+func addWatch(t *testing.T, w *Watcher, path ...string) {
+	t.Helper()
+	if len(path) < 1 {
+		t.Fatalf("addWatch: path must have at least one element: %s", path)
+	}
+	err := w.Add(filepath.Join(path...))
+	if err != nil {
+		t.Fatalf("addWatch(%q): %s", filepath.Join(path...), err)
+	}
+}
+
+const noWait = ""
+
+func shouldWait(path ...string) bool {
+	// Take advantage of the fact that filepath.Join skips empty parameters.
+	for _, p := range path {
+		if p == "" {
+			return false
+		}
+	}
+	return true
+}
+
+// Create n empty files with the prefix in the directory dir.
+func createFiles(t *testing.T, dir, prefix string, n int, d time.Duration) int {
+	t.Helper()
+
+	if d == 0 {
+		d = 9 * time.Minute
+	}
+
+	fmtNum := func(n int) string {
+		s := fmt.Sprintf("%09d", n)
+		return s[:3] + "_" + s[3:6] + "_" + s[6:]
+	}
+
+	var (
+		max     = time.After(d)
+		created int
+	)
+	for i := 0; i < n; i++ {
+		select {
+		case <-max:
+			t.Logf("createFiles: stopped at %s files because it took longer than %s", fmtNum(created), d)
+			return created
+		default:
+			fp, err := os.Create(filepath.Join(dir, prefix+fmtNum(i)))
+			if err != nil {
+				t.Errorf("create failed for %s: %s", fmtNum(i), err)
+				continue
+			}
+			if err := fp.Close(); err != nil {
+				t.Errorf("close failed for %s: %s", fmtNum(i), err)
+			}
+			if i%10_000 == 0 {
+				t.Logf("createFiles: %s", fmtNum(i))
+			}
+			created++
+		}
+	}
+	return created
+}
+
+// mkdir
+func mkdir(t *testing.T, path ...string) {
+	t.Helper()
+	if len(path) < 1 {
+		t.Fatalf("mkdir: path must have at least one element: %s", path)
+	}
+	err := os.Mkdir(filepath.Join(path...), 0o0755)
+	if err != nil {
+		t.Fatalf("mkdir(%q): %s", filepath.Join(path...), err)
+	}
+	if shouldWait(path...) {
+		eventSeparator()
+	}
+}
+
+// mkdir -p
+// func mkdirAll(t *testing.T, path ...string) {
+// 	t.Helper()
+// 	if len(path) < 1 {
+// 		t.Fatalf("mkdirAll: path must have at least one element: %s", path)
+// 	}
+// 	err := os.MkdirAll(filepath.Join(path...), 0o0755)
+// 	if err != nil {
+// 		t.Fatalf("mkdirAll(%q): %s", filepath.Join(path...), err)
+// 	}
+// 	if shouldWait(path...) {
+// 		eventSeparator()
+// 	}
+// }
+
+// ln -s
+func symlink(t *testing.T, target string, link ...string) {
+	t.Helper()
+	if len(link) < 1 {
+		t.Fatalf("symlink: link must have at least one element: %s", link)
+	}
+	err := os.Symlink(target, filepath.Join(link...))
+	if err != nil {
+		t.Fatalf("symlink(%q, %q): %s", target, filepath.Join(link...), err)
+	}
+	if shouldWait(link...) {
+		eventSeparator()
+	}
+}
+
+// mkfifo
+func mkfifo(t *testing.T, path ...string) {
+	t.Helper()
+	if len(path) < 1 {
+		t.Fatalf("mkfifo: path must have at least one element: %s", path)
+	}
+	err := internal.Mkfifo(filepath.Join(path...), 0o644)
+	if err != nil {
+		t.Fatalf("mkfifo(%q): %s", filepath.Join(path...), err)
+	}
+	if shouldWait(path...) {
+		eventSeparator()
+	}
+}
+
+// mknod
+func mknod(t *testing.T, dev int, path ...string) {
+	t.Helper()
+	if len(path) < 1 {
+		t.Fatalf("mknod: path must have at least one element: %s", path)
+	}
+	err := internal.Mknod(filepath.Join(path...), 0o644, dev)
+	if err != nil {
+		t.Fatalf("mknod(%d, %q): %s", dev, filepath.Join(path...), err)
+	}
+	if shouldWait(path...) {
+		eventSeparator()
+	}
+}
+
+// cat
+func cat(t *testing.T, data string, path ...string) {
+	t.Helper()
+	if len(path) < 1 {
+		t.Fatalf("cat: path must have at least one element: %s", path)
+	}
+
+	err := func() error {
+		fp, err := os.OpenFile(filepath.Join(path...), os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
+		if err != nil {
+			return err
+		}
+		if err := fp.Sync(); err != nil {
+			return err
+		}
+		if shouldWait(path...) {
+			eventSeparator()
+		}
+		if _, err := fp.WriteString(data); err != nil {
+			return err
+		}
+		if err := fp.Sync(); err != nil {
+			return err
+		}
+		if shouldWait(path...) {
+			eventSeparator()
+		}
+		return fp.Close()
+	}()
+	if err != nil {
+		t.Fatalf("cat(%q): %s", filepath.Join(path...), err)
+	}
+}
+
+// touch
+func touch(t *testing.T, path ...string) {
+	t.Helper()
+	if len(path) < 1 {
+		t.Fatalf("touch: path must have at least one element: %s", path)
+	}
+	fp, err := os.Create(filepath.Join(path...))
+	if err != nil {
+		t.Fatalf("touch(%q): %s", filepath.Join(path...), err)
+	}
+	err = fp.Close()
+	if err != nil {
+		t.Fatalf("touch(%q): %s", filepath.Join(path...), err)
+	}
+	if shouldWait(path...) {
+		eventSeparator()
+	}
+}
+
+// mv
+func mv(t *testing.T, src string, dst ...string) {
+	t.Helper()
+	if len(dst) < 1 {
+		t.Fatalf("mv: dst must have at least one element: %s", dst)
+	}
+
+	err := os.Rename(src, filepath.Join(dst...))
+	if err != nil {
+		t.Fatalf("mv(%q, %q): %s", src, filepath.Join(dst...), err)
+	}
+	if shouldWait(dst...) {
+		eventSeparator()
+	}
+}
+
+// rm
+func rm(t *testing.T, path ...string) {
+	t.Helper()
+	if len(path) < 1 {
+		t.Fatalf("rm: path must have at least one element: %s", path)
+	}
+	err := os.Remove(filepath.Join(path...))
+	if err != nil {
+		t.Fatalf("rm(%q): %s", filepath.Join(path...), err)
+	}
+	if shouldWait(path...) {
+		eventSeparator()
+	}
+}
+
+// rm -r
+func rmAll(t *testing.T, path ...string) {
+	t.Helper()
+	if len(path) < 1 {
+		t.Fatalf("rmAll: path must have at least one element: %s", path)
+	}
+	err := os.RemoveAll(filepath.Join(path...))
+	if err != nil {
+		t.Fatalf("rmAll(%q): %s", filepath.Join(path...), err)
+	}
+	if shouldWait(path...) {
+		eventSeparator()
+	}
+}
+
+// chmod
+func chmod(t *testing.T, mode fs.FileMode, path ...string) {
+	t.Helper()
+	if len(path) < 1 {
+		t.Fatalf("chmod: path must have at least one element: %s", path)
+	}
+	err := os.Chmod(filepath.Join(path...), mode)
+	if err != nil {
+		t.Fatalf("chmod(%q): %s", filepath.Join(path...), err)
+	}
+	if shouldWait(path...) {
+		eventSeparator()
+	}
+}
+
+// Collect all events in an array.
+//
+// w := newCollector(t)
+// w.collect(r)
+//
+// .. do stuff ..
+//
+// events := w.stop(t)
+type eventCollector struct {
+	w    *Watcher
+	e    Events
+	mu   sync.Mutex
+	done chan struct{}
+}
+
+func newCollector(t *testing.T, add ...string) *eventCollector {
+	return &eventCollector{
+		w:    newWatcher(t, add...),
+		done: make(chan struct{}),
+		e:    make(Events, 0, 8),
+	}
+}
+
+// stop collecting events and return what we've got.
+func (w *eventCollector) stop(t *testing.T) Events {
+	return w.stopWait(t, time.Second)
+}
+
+func (w *eventCollector) stopWait(t *testing.T, waitFor time.Duration) Events {
+	waitForEvents()
+
+	go func() {
+		err := w.w.Close()
+		if err != nil {
+			t.Error(err)
+		}
+	}()
+
+	select {
+	case <-time.After(waitFor):
+		t.Fatalf("event stream was not closed after %s", waitFor)
+	case <-w.done:
+	}
+
+	w.mu.Lock()
+	defer w.mu.Unlock()
+	return w.e
+}
+
+// Get all events we've found up to now and clear the event buffer.
+func (w *eventCollector) events(t *testing.T) Events {
+	w.mu.Lock()
+	defer w.mu.Unlock()
+
+	e := make(Events, len(w.e))
+	copy(e, w.e)
+	w.e = make(Events, 0, 16)
+	return e
+}
+
+// Start collecting events.
+func (w *eventCollector) collect(t *testing.T) {
+	go func() {
+		for {
+			select {
+			case e, ok := <-w.w.Errors:
+				if !ok {
+					w.done <- struct{}{}
+					return
+				}
+				t.Error(e)
+				return
+			case e, ok := <-w.w.Events:
+				if !ok {
+					w.done <- struct{}{}
+					return
+				}
+				w.mu.Lock()
+				w.e = append(w.e, e)
+				w.mu.Unlock()
+			}
+		}
+	}()
+}
+
+type Events []Event
+
+func (e Events) String() string {
+	b := new(strings.Builder)
+	for i, ee := range e {
+		if i > 0 {
+			b.WriteString("\n")
+		}
+		fmt.Fprintf(b, "%-20s %q", ee.Op.String(), filepath.ToSlash(ee.Name))
+	}
+	return b.String()
+}
+
+func (e Events) TrimPrefix(prefix string) Events {
+	for i := range e {
+		if e[i].Name == prefix {
+			e[i].Name = "/"
+		} else {
+			e[i].Name = strings.TrimPrefix(e[i].Name, prefix)
+		}
+	}
+	return e
+}
+
+func (e Events) copy() Events {
+	cp := make(Events, len(e))
+	copy(cp, e)
+	return cp
+}
+
+// Create a new Events list from a string; for example:
+//
+//   CREATE        path
+//   CREATE|WRITE  path
+//
+// Every event is one line, and any whitespace between the event and path are
+// ignored. The path can optionally be surrounded in ". Anything after a "#" is
+// ignored.
+//
+// Platform-specific tests can be added after GOOS:
+//
+//   # Tested if nothing else matches
+//   CREATE   path
+//
+//   # Windows-specific test.
+//   windows:
+//     WRITE    path
+//
+// You can specify multiple platforms with a comma (e.g. "windows, linux:").
+// "kqueue" is a shortcut for all kqueue systems (BSD, macOS).
+func newEvents(t *testing.T, s string) Events {
+	t.Helper()
+
+	var (
+		lines  = strings.Split(s, "\n")
+		groups = []string{""}
+		events = make(map[string]Events)
+	)
+	for no, line := range lines {
+		if i := strings.IndexByte(line, '#'); i > -1 {
+			line = line[:i]
+		}
+		line = strings.TrimSpace(line)
+		if line == "" {
+			continue
+		}
+		if strings.HasSuffix(line, ":") {
+			groups = strings.Split(strings.TrimRight(line, ":"), ",")
+			for i := range groups {
+				groups[i] = strings.TrimSpace(groups[i])
+			}
+			continue
+		}
+
+		fields := strings.Fields(line)
+		if len(fields) < 2 {
+			if strings.ToUpper(fields[0]) == "EMPTY" {
+				for _, g := range groups {
+					events[g] = Events{}
+				}
+				continue
+			}
+
+			t.Fatalf("newEvents: line %d has less than 2 fields: %s", no, line)
+		}
+
+		path := strings.Trim(fields[len(fields)-1], `"`)
+
+		var op Op
+		for _, e := range fields[:len(fields)-1] {
+			if e == "|" {
+				continue
+			}
+			for _, ee := range strings.Split(e, "|") {
+				switch strings.ToUpper(ee) {
+				case "CREATE":
+					op |= Create
+				case "WRITE":
+					op |= Write
+				case "REMOVE":
+					op |= Remove
+				case "RENAME":
+					op |= Rename
+				case "CHMOD":
+					op |= Chmod
+				default:
+					t.Fatalf("newEvents: line %d has unknown event %q: %s", no, ee, line)
+				}
+			}
+		}
+
+		for _, g := range groups {
+			events[g] = append(events[g], Event{Name: path, Op: op})
+		}
+	}
+
+	if e, ok := events[runtime.GOOS]; ok {
+		return e
+	}
+	switch runtime.GOOS {
+	// kqueue shortcut
+	case "freebsd", "netbsd", "openbsd", "dragonfly", "darwin":
+		if e, ok := events["kqueue"]; ok {
+			return e
+		}
+	// Fall back to solaris for illumos, and vice versa.
+	case "solaris":
+		if e, ok := events["illumos"]; ok {
+			return e
+		}
+	case "illumos":
+		if e, ok := events["solaris"]; ok {
+			return e
+		}
+	}
+	return events[""]
+}
+
+func cmpEvents(t *testing.T, tmp string, have, want Events) {
+	t.Helper()
+
+	have = have.TrimPrefix(tmp)
+
+	haveSort, wantSort := have.copy(), want.copy()
+	sort.Slice(haveSort, func(i, j int) bool {
+		return haveSort[i].String() > haveSort[j].String()
+	})
+	sort.Slice(wantSort, func(i, j int) bool {
+		return wantSort[i].String() > wantSort[j].String()
+	})
+
+	if haveSort.String() != wantSort.String() {
+		//t.Error("\n" + ztest.Diff(indent(haveSort), indent(wantSort)))
+		t.Errorf("\nhave:\n%s\nwant:\n%s", indent(have), indent(want))
+	}
+}
+
+func indent(s fmt.Stringer) string {
+	return "\t" + strings.ReplaceAll(s.String(), "\n", "\n\t")
+}
+
+func isCI() bool {
+	_, ok := os.LookupEnv("CI")
+	return ok
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/darwin.go b/go_package_port/github.com/fsnotify/fsnotify/internal/darwin.go
new file mode 100644
index 0000000..6a6d068
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/darwin.go
@@ -0,0 +1,40 @@
+//go:build darwin
+// +build darwin
+
+package internal
+
+import (
+	"syscall"
+
+	"golang.org/x/sys/unix"
+)
+
+var (
+	SyscallEACCES = syscall.EACCES
+	UnixEACCES    = unix.EACCES
+)
+
+var maxfiles uint64
+
+// Go 1.19 will do this automatically: https://go-review.googlesource.com/c/go/+/393354/
+func SetRlimit() {
+	var l syscall.Rlimit
+	err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &l)
+	if err == nil && l.Cur != l.Max {
+		l.Cur = l.Max
+		syscall.Setrlimit(syscall.RLIMIT_NOFILE, &l)
+	}
+	maxfiles = l.Cur
+
+	if n, err := syscall.SysctlUint32("kern.maxfiles"); err == nil && uint64(n) < maxfiles {
+		maxfiles = uint64(n)
+	}
+
+	if n, err := syscall.SysctlUint32("kern.maxfilesperproc"); err == nil && uint64(n) < maxfiles {
+		maxfiles = uint64(n)
+	}
+}
+
+func Maxfiles() uint64                              { return maxfiles }
+func Mkfifo(path string, mode uint32) error         { return unix.Mkfifo(path, mode) }
+func Mknod(path string, mode uint32, dev int) error { return unix.Mknod(path, mode, dev) }
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/debug_darwin.go b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_darwin.go
new file mode 100644
index 0000000..928319f
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_darwin.go
@@ -0,0 +1,57 @@
+package internal
+
+import "golang.org/x/sys/unix"
+
+var names = []struct {
+	n string
+	m uint32
+}{
+	{"NOTE_ABSOLUTE", unix.NOTE_ABSOLUTE},
+	{"NOTE_ATTRIB", unix.NOTE_ATTRIB},
+	{"NOTE_BACKGROUND", unix.NOTE_BACKGROUND},
+	{"NOTE_CHILD", unix.NOTE_CHILD},
+	{"NOTE_CRITICAL", unix.NOTE_CRITICAL},
+	{"NOTE_DELETE", unix.NOTE_DELETE},
+	{"NOTE_EXEC", unix.NOTE_EXEC},
+	{"NOTE_EXIT", unix.NOTE_EXIT},
+	{"NOTE_EXITSTATUS", unix.NOTE_EXITSTATUS},
+	{"NOTE_EXIT_CSERROR", unix.NOTE_EXIT_CSERROR},
+	{"NOTE_EXIT_DECRYPTFAIL", unix.NOTE_EXIT_DECRYPTFAIL},
+	{"NOTE_EXIT_DETAIL", unix.NOTE_EXIT_DETAIL},
+	{"NOTE_EXIT_DETAIL_MASK", unix.NOTE_EXIT_DETAIL_MASK},
+	{"NOTE_EXIT_MEMORY", unix.NOTE_EXIT_MEMORY},
+	{"NOTE_EXIT_REPARENTED", unix.NOTE_EXIT_REPARENTED},
+	{"NOTE_EXTEND", unix.NOTE_EXTEND},
+	{"NOTE_FFAND", unix.NOTE_FFAND},
+	{"NOTE_FFCOPY", unix.NOTE_FFCOPY},
+	{"NOTE_FFCTRLMASK", unix.NOTE_FFCTRLMASK},
+	{"NOTE_FFLAGSMASK", unix.NOTE_FFLAGSMASK},
+	{"NOTE_FFNOP", unix.NOTE_FFNOP},
+	{"NOTE_FFOR", unix.NOTE_FFOR},
+	{"NOTE_FORK", unix.NOTE_FORK},
+	{"NOTE_FUNLOCK", unix.NOTE_FUNLOCK},
+	{"NOTE_LEEWAY", unix.NOTE_LEEWAY},
+	{"NOTE_LINK", unix.NOTE_LINK},
+	{"NOTE_LOWAT", unix.NOTE_LOWAT},
+	{"NOTE_MACHTIME", unix.NOTE_MACHTIME},
+	{"NOTE_MACH_CONTINUOUS_TIME", unix.NOTE_MACH_CONTINUOUS_TIME},
+	{"NOTE_NONE", unix.NOTE_NONE},
+	{"NOTE_NSECONDS", unix.NOTE_NSECONDS},
+	{"NOTE_OOB", unix.NOTE_OOB},
+	//{"NOTE_PCTRLMASK", unix.NOTE_PCTRLMASK}, -0x100000 (?!)
+	{"NOTE_PDATAMASK", unix.NOTE_PDATAMASK},
+	{"NOTE_REAP", unix.NOTE_REAP},
+	{"NOTE_RENAME", unix.NOTE_RENAME},
+	{"NOTE_REVOKE", unix.NOTE_REVOKE},
+	{"NOTE_SECONDS", unix.NOTE_SECONDS},
+	{"NOTE_SIGNAL", unix.NOTE_SIGNAL},
+	{"NOTE_TRACK", unix.NOTE_TRACK},
+	{"NOTE_TRACKERR", unix.NOTE_TRACKERR},
+	{"NOTE_TRIGGER", unix.NOTE_TRIGGER},
+	{"NOTE_USECONDS", unix.NOTE_USECONDS},
+	{"NOTE_VM_ERROR", unix.NOTE_VM_ERROR},
+	{"NOTE_VM_PRESSURE", unix.NOTE_VM_PRESSURE},
+	{"NOTE_VM_PRESSURE_SUDDEN_TERMINATE", unix.NOTE_VM_PRESSURE_SUDDEN_TERMINATE},
+	{"NOTE_VM_PRESSURE_TERMINATE", unix.NOTE_VM_PRESSURE_TERMINATE},
+	{"NOTE_WRITE", unix.NOTE_WRITE},
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/debug_dragonfly.go b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_dragonfly.go
new file mode 100644
index 0000000..3186b0c
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_dragonfly.go
@@ -0,0 +1,33 @@
+package internal
+
+import "golang.org/x/sys/unix"
+
+var names = []struct {
+	n string
+	m uint32
+}{
+	{"NOTE_ATTRIB", unix.NOTE_ATTRIB},
+	{"NOTE_CHILD", unix.NOTE_CHILD},
+	{"NOTE_DELETE", unix.NOTE_DELETE},
+	{"NOTE_EXEC", unix.NOTE_EXEC},
+	{"NOTE_EXIT", unix.NOTE_EXIT},
+	{"NOTE_EXTEND", unix.NOTE_EXTEND},
+	{"NOTE_FFAND", unix.NOTE_FFAND},
+	{"NOTE_FFCOPY", unix.NOTE_FFCOPY},
+	{"NOTE_FFCTRLMASK", unix.NOTE_FFCTRLMASK},
+	{"NOTE_FFLAGSMASK", unix.NOTE_FFLAGSMASK},
+	{"NOTE_FFNOP", unix.NOTE_FFNOP},
+	{"NOTE_FFOR", unix.NOTE_FFOR},
+	{"NOTE_FORK", unix.NOTE_FORK},
+	{"NOTE_LINK", unix.NOTE_LINK},
+	{"NOTE_LOWAT", unix.NOTE_LOWAT},
+	{"NOTE_OOB", unix.NOTE_OOB},
+	{"NOTE_PCTRLMASK", unix.NOTE_PCTRLMASK},
+	{"NOTE_PDATAMASK", unix.NOTE_PDATAMASK},
+	{"NOTE_RENAME", unix.NOTE_RENAME},
+	{"NOTE_REVOKE", unix.NOTE_REVOKE},
+	{"NOTE_TRACK", unix.NOTE_TRACK},
+	{"NOTE_TRACKERR", unix.NOTE_TRACKERR},
+	{"NOTE_TRIGGER", unix.NOTE_TRIGGER},
+	{"NOTE_WRITE", unix.NOTE_WRITE},
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/debug_freebsd.go b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_freebsd.go
new file mode 100644
index 0000000..f69fdb9
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_freebsd.go
@@ -0,0 +1,42 @@
+package internal
+
+import "golang.org/x/sys/unix"
+
+var names = []struct {
+	n string
+	m uint32
+}{
+	{"NOTE_ABSTIME", unix.NOTE_ABSTIME},
+	{"NOTE_ATTRIB", unix.NOTE_ATTRIB},
+	{"NOTE_CHILD", unix.NOTE_CHILD},
+	{"NOTE_CLOSE", unix.NOTE_CLOSE},
+	{"NOTE_CLOSE_WRITE", unix.NOTE_CLOSE_WRITE},
+	{"NOTE_DELETE", unix.NOTE_DELETE},
+	{"NOTE_EXEC", unix.NOTE_EXEC},
+	{"NOTE_EXIT", unix.NOTE_EXIT},
+	{"NOTE_EXTEND", unix.NOTE_EXTEND},
+	{"NOTE_FFAND", unix.NOTE_FFAND},
+	{"NOTE_FFCOPY", unix.NOTE_FFCOPY},
+	{"NOTE_FFCTRLMASK", unix.NOTE_FFCTRLMASK},
+	{"NOTE_FFLAGSMASK", unix.NOTE_FFLAGSMASK},
+	{"NOTE_FFNOP", unix.NOTE_FFNOP},
+	{"NOTE_FFOR", unix.NOTE_FFOR},
+	{"NOTE_FILE_POLL", unix.NOTE_FILE_POLL},
+	{"NOTE_FORK", unix.NOTE_FORK},
+	{"NOTE_LINK", unix.NOTE_LINK},
+	{"NOTE_LOWAT", unix.NOTE_LOWAT},
+	{"NOTE_MSECONDS", unix.NOTE_MSECONDS},
+	{"NOTE_NSECONDS", unix.NOTE_NSECONDS},
+	{"NOTE_OPEN", unix.NOTE_OPEN},
+	{"NOTE_PCTRLMASK", unix.NOTE_PCTRLMASK},
+	{"NOTE_PDATAMASK", unix.NOTE_PDATAMASK},
+	{"NOTE_READ", unix.NOTE_READ},
+	{"NOTE_RENAME", unix.NOTE_RENAME},
+	{"NOTE_REVOKE", unix.NOTE_REVOKE},
+	{"NOTE_SECONDS", unix.NOTE_SECONDS},
+	{"NOTE_TRACK", unix.NOTE_TRACK},
+	{"NOTE_TRACKERR", unix.NOTE_TRACKERR},
+	{"NOTE_TRIGGER", unix.NOTE_TRIGGER},
+	{"NOTE_USECONDS", unix.NOTE_USECONDS},
+	{"NOTE_WRITE", unix.NOTE_WRITE},
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/debug_kqueue.go b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_kqueue.go
new file mode 100644
index 0000000..47f7660
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_kqueue.go
@@ -0,0 +1,27 @@
+//go:build freebsd || openbsd || netbsd || dragonfly || darwin
+// +build freebsd openbsd netbsd dragonfly darwin
+
+package internal
+
+import (
+	"fmt"
+	"os"
+	"strings"
+	"time"
+
+	"golang.org/x/sys/unix"
+)
+
+func Debug(name string, kevent *unix.Kevent_t) {
+	mask := uint32(kevent.Fflags)
+	var l []string
+	for _, n := range names {
+		if mask&n.m == n.m {
+			l = append(l, n.n)
+		}
+	}
+
+	fmt.Fprintf(os.Stderr, "%s  %-20s → %s\n",
+		time.Now().Format("15:04:05.0000"),
+		strings.Join(l, " | "), name)
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/debug_linux.go b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_linux.go
new file mode 100644
index 0000000..86613b9
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_linux.go
@@ -0,0 +1,63 @@
+package internal
+
+import (
+	"fmt"
+	"os"
+	"strings"
+	"time"
+
+	"golang.org/x/sys/unix"
+)
+
+func Debug(name string, mask uint32) {
+	names := []struct {
+		n string
+		m uint32
+	}{
+		{"IN_ACCESS", unix.IN_ACCESS},
+		{"IN_ALL_EVENTS", unix.IN_ALL_EVENTS},
+		{"IN_ATTRIB", unix.IN_ATTRIB},
+		{"IN_CLASSA_HOST", unix.IN_CLASSA_HOST},
+		{"IN_CLASSA_MAX", unix.IN_CLASSA_MAX},
+		{"IN_CLASSA_NET", unix.IN_CLASSA_NET},
+		{"IN_CLASSA_NSHIFT", unix.IN_CLASSA_NSHIFT},
+		{"IN_CLASSB_HOST", unix.IN_CLASSB_HOST},
+		{"IN_CLASSB_MAX", unix.IN_CLASSB_MAX},
+		{"IN_CLASSB_NET", unix.IN_CLASSB_NET},
+		{"IN_CLASSB_NSHIFT", unix.IN_CLASSB_NSHIFT},
+		{"IN_CLASSC_HOST", unix.IN_CLASSC_HOST},
+		{"IN_CLASSC_NET", unix.IN_CLASSC_NET},
+		{"IN_CLASSC_NSHIFT", unix.IN_CLASSC_NSHIFT},
+		{"IN_CLOSE", unix.IN_CLOSE},
+		{"IN_CLOSE_NOWRITE", unix.IN_CLOSE_NOWRITE},
+		{"IN_CLOSE_WRITE", unix.IN_CLOSE_WRITE},
+		{"IN_CREATE", unix.IN_CREATE},
+		{"IN_DELETE", unix.IN_DELETE},
+		{"IN_DELETE_SELF", unix.IN_DELETE_SELF},
+		{"IN_DONT_FOLLOW", unix.IN_DONT_FOLLOW},
+		{"IN_EXCL_UNLINK", unix.IN_EXCL_UNLINK},
+		{"IN_IGNORED", unix.IN_IGNORED},
+		{"IN_ISDIR", unix.IN_ISDIR},
+		{"IN_LOOPBACKNET", unix.IN_LOOPBACKNET},
+		{"IN_MASK_ADD", unix.IN_MASK_ADD},
+		{"IN_MASK_CREATE", unix.IN_MASK_CREATE},
+		{"IN_MODIFY", unix.IN_MODIFY},
+		{"IN_MOVE", unix.IN_MOVE},
+		{"IN_MOVED_FROM", unix.IN_MOVED_FROM},
+		{"IN_MOVED_TO", unix.IN_MOVED_TO},
+		{"IN_MOVE_SELF", unix.IN_MOVE_SELF},
+		{"IN_ONESHOT", unix.IN_ONESHOT},
+		{"IN_ONLYDIR", unix.IN_ONLYDIR},
+		{"IN_OPEN", unix.IN_OPEN},
+		{"IN_Q_OVERFLOW", unix.IN_Q_OVERFLOW},
+		{"IN_UNMOUNT", unix.IN_UNMOUNT},
+	}
+
+	var l []string
+	for _, n := range names {
+		if mask&n.m == n.m {
+			l = append(l, n.n)
+		}
+	}
+	fmt.Fprintf(os.Stderr, "%s  %-20s → %s\n", time.Now().Format("15:04:05.0000"), strings.Join(l, " | "), name)
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/debug_netbsd.go b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_netbsd.go
new file mode 100644
index 0000000..e5b3b6f
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_netbsd.go
@@ -0,0 +1,25 @@
+package internal
+
+import "golang.org/x/sys/unix"
+
+var names = []struct {
+	n string
+	m uint32
+}{
+	{"NOTE_ATTRIB", unix.NOTE_ATTRIB},
+	{"NOTE_CHILD", unix.NOTE_CHILD},
+	{"NOTE_DELETE", unix.NOTE_DELETE},
+	{"NOTE_EXEC", unix.NOTE_EXEC},
+	{"NOTE_EXIT", unix.NOTE_EXIT},
+	{"NOTE_EXTEND", unix.NOTE_EXTEND},
+	{"NOTE_FORK", unix.NOTE_FORK},
+	{"NOTE_LINK", unix.NOTE_LINK},
+	{"NOTE_LOWAT", unix.NOTE_LOWAT},
+	{"NOTE_PCTRLMASK", unix.NOTE_PCTRLMASK},
+	{"NOTE_PDATAMASK", unix.NOTE_PDATAMASK},
+	{"NOTE_RENAME", unix.NOTE_RENAME},
+	{"NOTE_REVOKE", unix.NOTE_REVOKE},
+	{"NOTE_TRACK", unix.NOTE_TRACK},
+	{"NOTE_TRACKERR", unix.NOTE_TRACKERR},
+	{"NOTE_WRITE", unix.NOTE_WRITE},
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/debug_openbsd.go b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_openbsd.go
new file mode 100644
index 0000000..996b441
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_openbsd.go
@@ -0,0 +1,28 @@
+package internal
+
+import "golang.org/x/sys/unix"
+
+var names = []struct {
+	n string
+	m uint32
+}{
+	{"NOTE_ATTRIB", unix.NOTE_ATTRIB},
+	{"NOTE_CHANGE", unix.NOTE_CHANGE},
+	{"NOTE_CHILD", unix.NOTE_CHILD},
+	{"NOTE_DELETE", unix.NOTE_DELETE},
+	{"NOTE_EOF", unix.NOTE_EOF},
+	{"NOTE_EXEC", unix.NOTE_EXEC},
+	{"NOTE_EXIT", unix.NOTE_EXIT},
+	{"NOTE_EXTEND", unix.NOTE_EXTEND},
+	{"NOTE_FORK", unix.NOTE_FORK},
+	{"NOTE_LINK", unix.NOTE_LINK},
+	{"NOTE_LOWAT", unix.NOTE_LOWAT},
+	{"NOTE_PCTRLMASK", unix.NOTE_PCTRLMASK},
+	{"NOTE_PDATAMASK", unix.NOTE_PDATAMASK},
+	{"NOTE_RENAME", unix.NOTE_RENAME},
+	{"NOTE_REVOKE", unix.NOTE_REVOKE},
+	{"NOTE_TRACK", unix.NOTE_TRACK},
+	{"NOTE_TRACKERR", unix.NOTE_TRACKERR},
+	{"NOTE_TRUNCATE", unix.NOTE_TRUNCATE},
+	{"NOTE_WRITE", unix.NOTE_WRITE},
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/debug_windows.go b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_windows.go
new file mode 100644
index 0000000..50b117f
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/debug_windows.go
@@ -0,0 +1,39 @@
+package internal
+
+import (
+	"fmt"
+	"os"
+	"strings"
+	"time"
+
+	"golang.org/x/sys/windows"
+)
+
+func Debug(name string, mask uint32) {
+	names := []struct {
+		n string
+		m uint32
+	}{
+		//{"FILE_NOTIFY_CHANGE_FILE_NAME", windows.FILE_NOTIFY_CHANGE_FILE_NAME},
+		//{"FILE_NOTIFY_CHANGE_DIR_NAME", windows.FILE_NOTIFY_CHANGE_DIR_NAME},
+		//{"FILE_NOTIFY_CHANGE_ATTRIBUTES", windows.FILE_NOTIFY_CHANGE_ATTRIBUTES},
+		//{"FILE_NOTIFY_CHANGE_SIZE", windows.FILE_NOTIFY_CHANGE_SIZE},
+		//{"FILE_NOTIFY_CHANGE_LAST_WRITE", windows.FILE_NOTIFY_CHANGE_LAST_WRITE},
+		//{"FILE_NOTIFY_CHANGE_LAST_ACCESS", windows.FILE_NOTIFY_CHANGE_LAST_ACCESS},
+		//{"FILE_NOTIFY_CHANGE_CREATION", windows.FILE_NOTIFY_CHANGE_CREATION},
+		//{"FILE_NOTIFY_CHANGE_SECURITY", windows.FILE_NOTIFY_CHANGE_SECURITY},
+		{"FILE_ACTION_ADDED", windows.FILE_ACTION_ADDED},
+		{"FILE_ACTION_REMOVED", windows.FILE_ACTION_REMOVED},
+		{"FILE_ACTION_MODIFIED", windows.FILE_ACTION_MODIFIED},
+		{"FILE_ACTION_RENAMED_OLD_NAME", windows.FILE_ACTION_RENAMED_OLD_NAME},
+		{"FILE_ACTION_RENAMED_NEW_NAME", windows.FILE_ACTION_RENAMED_NEW_NAME},
+	}
+
+	var l []string
+	for _, n := range names {
+		if mask&n.m == n.m {
+			l = append(l, n.n)
+		}
+	}
+	fmt.Fprintf(os.Stderr, "%s  %-20s → %s\n", time.Now().Format("15:04:05.0000"), strings.Join(l, " | "), name)
+}
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/freebsd.go b/go_package_port/github.com/fsnotify/fsnotify/internal/freebsd.go
new file mode 100644
index 0000000..4128482
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/freebsd.go
@@ -0,0 +1,32 @@
+//go:build freebsd
+// +build freebsd
+
+package internal
+
+import (
+	"syscall"
+
+	"golang.org/x/sys/unix"
+)
+
+var (
+	SyscallEACCES = syscall.EACCES
+	UnixEACCES    = unix.EACCES
+)
+
+var maxfiles uint64
+
+// Go 1.19 will do this automatically: https://go-review.googlesource.com/c/go/+/393354/
+func SetRlimit() {
+	var l syscall.Rlimit
+	err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &l)
+	if err == nil && l.Cur != l.Max {
+		l.Cur = l.Max
+		syscall.Setrlimit(syscall.RLIMIT_NOFILE, &l)
+	}
+	maxfiles = uint64(l.Cur)
+}
+
+func Maxfiles() uint64                              { return maxfiles }
+func Mkfifo(path string, mode uint32) error         { return unix.Mkfifo(path, mode) }
+func Mknod(path string, mode uint32, dev int) error { return unix.Mknod(path, mode, uint64(dev)) }
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/unix.go b/go_package_port/github.com/fsnotify/fsnotify/internal/unix.go
new file mode 100644
index 0000000..301b242
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/unix.go
@@ -0,0 +1,32 @@
+//go:build !windows && !darwin && !freebsd
+// +build !windows,!darwin,!freebsd
+
+package internal
+
+import (
+	"syscall"
+
+	"golang.org/x/sys/unix"
+)
+
+var (
+	SyscallEACCES = syscall.EACCES
+	UnixEACCES    = unix.EACCES
+)
+
+var maxfiles uint64
+
+// Go 1.19 will do this automatically: https://go-review.googlesource.com/c/go/+/393354/
+func SetRlimit() {
+	var l syscall.Rlimit
+	err := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &l)
+	if err == nil && l.Cur != l.Max {
+		l.Cur = l.Max
+		syscall.Setrlimit(syscall.RLIMIT_NOFILE, &l)
+	}
+	maxfiles = uint64(l.Cur)
+}
+
+func Maxfiles() uint64                              { return maxfiles }
+func Mkfifo(path string, mode uint32) error         { return unix.Mkfifo(path, mode) }
+func Mknod(path string, mode uint32, dev int) error { return unix.Mknod(path, mode, dev) }
diff --git a/go_package_port/github.com/fsnotify/fsnotify/internal/windows.go b/go_package_port/github.com/fsnotify/fsnotify/internal/windows.go
new file mode 100644
index 0000000..0e9b3b2
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/internal/windows.go
@@ -0,0 +1,19 @@
+//go:build windows
+// +build windows
+
+package internal
+
+import (
+	"errors"
+)
+
+// Just a dummy.
+var (
+	SyscallEACCES = errors.New("dummy")
+	UnixEACCES    = errors.New("dummy")
+)
+
+func SetRlimit()                                    {}
+func Maxfiles() uint64                              { return 1<<64 - 1 }
+func Mkfifo(path string, mode uint32) error         { return errors.New("no FIFOs on Windows") }
+func Mknod(path string, mode uint32, dev int) error { return errors.New("no device nodes on Windows") }
diff --git a/go_package_port/github.com/fsnotify/fsnotify/mkdoc.zsh b/go_package_port/github.com/fsnotify/fsnotify/mkdoc.zsh
new file mode 100644
index 0000000..b09ef76
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/mkdoc.zsh
@@ -0,0 +1,208 @@
+#!/usr/bin/env zsh
+[ "${ZSH_VERSION:-}" = "" ] && echo >&2 "Only works with zsh" && exit 1
+setopt err_exit no_unset pipefail extended_glob
+
+# Simple script to update the godoc comments on all watchers. Probably took me
+# more time to write this than doing it manually, but ah well 🙃
+
+watcher=$(<<EOF
+// Watcher watches a set of paths, delivering events on a channel.
+//
+// A watcher should not be copied (e.g. pass it by pointer, rather than by
+// value).
+//
+// # Linux notes
+//
+// When a file is removed a Remove event won't be emitted until all file
+// descriptors are closed, and deletes will always emit a Chmod. For example:
+//
+//     fp := os.Open("file")
+//     os.Remove("file")        // Triggers Chmod
+//     fp.Close()               // Triggers Remove
+//
+// This is the event that inotify sends, so not much can be changed about this.
+//
+// The fs.inotify.max_user_watches sysctl variable specifies the upper limit
+// for the number of watches per user, and fs.inotify.max_user_instances
+// specifies the maximum number of inotify instances per user. Every Watcher you
+// create is an "instance", and every path you add is a "watch".
+//
+// These are also exposed in /proc as /proc/sys/fs/inotify/max_user_watches and
+// /proc/sys/fs/inotify/max_user_instances
+//
+// To increase them you can use sysctl or write the value to the /proc file:
+//
+//     # Default values on Linux 5.18
+//     sysctl fs.inotify.max_user_watches=124983
+//     sysctl fs.inotify.max_user_instances=128
+//
+// To make the changes persist on reboot edit /etc/sysctl.conf or
+// /usr/lib/sysctl.d/50-default.conf (details differ per Linux distro; check
+// your distro's documentation):
+//
+//     fs.inotify.max_user_watches=124983
+//     fs.inotify.max_user_instances=128
+//
+// Reaching the limit will result in a "no space left on device" or "too many open
+// files" error.
+//
+// # kqueue notes (macOS, BSD)
+//
+// kqueue requires opening a file descriptor for every file that's being watched;
+// so if you're watching a directory with five files then that's six file
+// descriptors. You will run in to your system's "max open files" limit faster on
+// these platforms.
+//
+// The sysctl variables kern.maxfiles and kern.maxfilesperproc can be used to
+// control the maximum number of open files, as well as /etc/login.conf on BSD
+// systems.
+//
+// # macOS notes
+//
+// Spotlight indexing on macOS can result in multiple events (see [#15]). A
+// temporary workaround is to add your folder(s) to the "Spotlight Privacy
+// Settings" until we have a native FSEvents implementation (see [#11]).
+//
+// [#11]: https://github.com/fsnotify/fsnotify/issues/11
+// [#15]: https://github.com/fsnotify/fsnotify/issues/15
+EOF
+)
+
+new=$(<<EOF
+// NewWatcher creates a new Watcher.
+EOF
+)
+
+add=$(<<EOF
+// Add starts monitoring the path for changes.
+//
+// A path can only be watched once; attempting to watch it more than once will
+// return an error. Paths that do not yet exist on the filesystem cannot be
+// added. A watch will be automatically removed if the path is deleted.
+//
+// A path will remain watched if it gets renamed to somewhere else on the same
+// filesystem, but the monitor will get removed if the path gets deleted and
+// re-created, or if it's moved to a different filesystem.
+//
+// Notifications on network filesystems (NFS, SMB, FUSE, etc.) or special
+// filesystems (/proc, /sys, etc.) generally don't work.
+//
+// # Watching directories
+//
+// All files in a directory are monitored, including new files that are created
+// after the watcher is started. Subdirectories are not watched (i.e. it's
+// non-recursive).
+//
+// # Watching files
+//
+// Watching individual files (rather than directories) is generally not
+// recommended as many tools update files atomically. Instead of "just" writing
+// to the file a temporary file will be written to first, and if successful the
+// temporary file is moved to to destination removing the original, or some
+// variant thereof. The watcher on the original file is now lost, as it no
+// longer exists.
+//
+// Instead, watch the parent directory and use Event.Name to filter out files
+// you're not interested in. There is an example of this in [cmd/fsnotify/file.go].
+EOF
+)
+
+remove=$(<<EOF
+// Remove stops monitoring the path for changes.
+//
+// Directories are always removed non-recursively. For example, if you added
+// /tmp/dir and /tmp/dir/subdir then you will need to remove both.
+//
+// Removing a path that has not yet been added returns [ErrNonExistentWatch].
+EOF
+)
+
+close=$(<<EOF
+// Close removes all watches and closes the events channel.
+EOF
+)
+
+watchlist=$(<<EOF
+// WatchList returns all paths added with [Add] (and are not yet removed).
+EOF
+)
+
+events=$(<<EOF
+	// Events sends the filesystem change events.
+	//
+	// fsnotify can send the following events; a "path" here can refer to a
+	// file, directory, symbolic link, or special file like a FIFO.
+	//
+	//   fsnotify.Create    A new path was created; this may be followed by one
+	//                      or more Write events if data also gets written to a
+	//                      file.
+	//
+	//   fsnotify.Remove    A path was removed.
+	//
+	//   fsnotify.Rename    A path was renamed. A rename is always sent with the
+	//                      old path as Event.Name, and a Create event will be
+	//                      sent with the new name. Renames are only sent for
+	//                      paths that are currently watched; e.g. moving an
+	//                      unmonitored file into a monitored directory will
+	//                      show up as just a Create. Similarly, renaming a file
+	//                      to outside a monitored directory will show up as
+	//                      only a Rename.
+	//
+	//   fsnotify.Write     A file or named pipe was written to. A Truncate will
+	//                      also trigger a Write. A single "write action"
+	//                      initiated by the user may show up as one or multiple
+	//                      writes, depending on when the system syncs things to
+	//                      disk. For example when compiling a large Go program
+	//                      you may get hundreds of Write events, so you
+	//                      probably want to wait until you've stopped receiving
+	//                      them (see the dedup example in cmd/fsnotify).
+	//
+	//   fsnotify.Chmod     Attributes were changed. On Linux this is also sent
+	//                      when a file is removed (or more accurately, when a
+	//                      link to an inode is removed). On kqueue it's sent
+	//                      and on kqueue when a file is truncated. On Windows
+	//                      it's never sent.
+EOF
+)
+
+errors=$(<<EOF
+	// Errors sends any errors.
+EOF
+)
+
+set-cmt() {
+	local pat=$1
+	local cmt=$2
+
+	IFS=$'\n' local files=($(grep -n $pat backend_*~*_test.go))
+	for f in $files; do
+		IFS=':' local fields=($=f)
+		local file=$fields[1]
+		local end=$(( $fields[2] - 1 ))
+
+		# Find start of comment.
+		local start=0
+		IFS=$'\n' local lines=($(head -n$end $file))
+		for (( i = 1; i <= $#lines; i++ )); do
+			local line=$lines[-$i]
+			if ! grep -q '^[[:space:]]*//' <<<$line; then
+				start=$(( end - (i - 2) ))
+				break
+			fi
+		done
+
+		head -n $(( start - 1 )) $file  >/tmp/x
+		print -r -- $cmt                >>/tmp/x
+		tail -n+$(( end + 1 ))   $file  >>/tmp/x
+		mv /tmp/x $file
+	done
+}
+
+set-cmt '^type Watcher struct '             $watcher
+set-cmt '^func NewWatcher('                 $new
+set-cmt '^func (w \*Watcher) Add('          $add
+set-cmt '^func (w \*Watcher) Remove('       $remove
+set-cmt '^func (w \*Watcher) Close('        $close
+set-cmt '^func (w \*Watcher) WatchList('    $watchlist
+set-cmt '^[[:space:]]*Events *chan Event$'  $events
+set-cmt '^[[:space:]]*Errors *chan error$'  $errors
diff --git a/go_package_port/github.com/fsnotify/fsnotify/system_bsd.go b/go_package_port/github.com/fsnotify/fsnotify/system_bsd.go
new file mode 100644
index 0000000..4322b0b
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/system_bsd.go
@@ -0,0 +1,8 @@
+//go:build freebsd || openbsd || netbsd || dragonfly
+// +build freebsd openbsd netbsd dragonfly
+
+package fsnotify
+
+import "golang.org/x/sys/unix"
+
+const openMode = unix.O_NONBLOCK | unix.O_RDONLY | unix.O_CLOEXEC
diff --git a/go_package_port/github.com/fsnotify/fsnotify/system_darwin.go b/go_package_port/github.com/fsnotify/fsnotify/system_darwin.go
new file mode 100644
index 0000000..5da5ffa
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/system_darwin.go
@@ -0,0 +1,9 @@
+//go:build darwin
+// +build darwin
+
+package fsnotify
+
+import "golang.org/x/sys/unix"
+
+// note: this constant is not defined on BSD
+const openMode = unix.O_EVTONLY | unix.O_CLOEXEC
diff --git a/go_package_port/github.com/fsnotify/fsnotify/system_darwin_test.go b/go_package_port/github.com/fsnotify/fsnotify/system_darwin_test.go
new file mode 100644
index 0000000..48cabe9
--- /dev/null
+++ b/go_package_port/github.com/fsnotify/fsnotify/system_darwin_test.go
@@ -0,0 +1,123 @@
+//go:build darwin
+// +build darwin
+
+package fsnotify
+
+import (
+	"os"
+	"path/filepath"
+	"strconv"
+	"strings"
+	"testing"
+
+	"golang.org/x/sys/unix"
+)
+
+// darwinVersion returns version os Darwin (17 is macOS 10.13).
+func darwinVersion() (int, error) {
+	s, err := unix.Sysctl("kern.osrelease")
+	if err != nil {
+		return 0, err
+	}
+	s = strings.Split(s, ".")[0]
+	return strconv.Atoi(s)
+}
+
+// testExchangedataForWatcher tests the watcher with the exchangedata operation
+// on macOS. This is widely used for atomic saves on macOS, e.g. TextMate and in
+// Apple's NSDocument.
+//
+// https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/exchangedata.2.html
+// https://github.com/textmate/textmate/blob/cd016be2/Frameworks/io/src/swap_file_data.cc#L20
+func testExchangedataForWatcher(t *testing.T, watchDir bool) {
+	osVersion, err := darwinVersion()
+	if err != nil {
+		t.Fatal("unable to get Darwin version:", err)
+	}
+	if osVersion >= 17 {
+		t.Skip("Exchangedata is deprecated in macOS 10.13")
+	}
+
+	testDir1 := t.TempDir() // Create directory to watch
+	testDir2 := t.TempDir() // For the intermediate file
+
+	resolvedFilename := "TestFsnotifyEvents.file"
+
+	// TextMate does:
+	//
+	// 1. exchangedata (intermediate, resolved)
+	// 2. unlink intermediate
+	//
+	// Let's try to simulate that:
+	resolved := filepath.Join(testDir1, resolvedFilename)
+	intermediate := filepath.Join(testDir2, resolvedFilename+"~")
+
+	// Make sure we create the file before we start watching
+	createAndSyncFile(t, resolved)
+
+	w := newCollector(t)
+	w.collect(t)
+
+	// Test both variants in isolation
+	if watchDir {
+		addWatch(t, w.w, testDir1)
+	} else {
+		addWatch(t, w.w, resolved)
+	}
+
+	// Repeat to make sure the watched file/directory "survives" the
+	// REMOVE/CREATE loop.
+	for i := 1; i <= 3; i++ {
+		createAndSyncFile(t, intermediate) // intermediate file is created outside the watcher
+
+		if err := unix.Exchangedata(intermediate, resolved, 0); err != nil { // 1. Swap
+			t.Fatalf("[%d] exchangedata failed: %s", i, err)
+		}
+		eventSeparator()
+		err := os.Remove(intermediate) // delete the intermediate file
+		if err != nil {
+			t.Fatalf("[%d] remove %s failed: %s", i, intermediate, err)
+		}
+
+		eventSeparator()
+	}
+
+	// The events will be (CHMOD + REMOVE + CREATE) X 2. Let's focus on the last two:
+	events := w.stop(t)
+	var rm, create Events
+	for _, e := range events {
+		if e.Has(Create) {
+			create = append(create, e)
+		}
+		if e.Has(Remove) {
+			rm = append(rm, e)
+		}
+	}
+	if len(rm) < 3 {
+		t.Fatalf("less than 3 REMOVE events:\n%s", events)
+	}
+	if len(create) < 3 {
+		t.Fatalf("less than 3 CREATE events:\n%s", events)
+	}
+}
+
+func createAndSyncFile(t *testing.T, filepath string) {
+	f1, err := os.OpenFile(filepath, os.O_WRONLY|os.O_CREATE, 0666)
+	if err != nil {
+		t.Fatalf("creating %s failed: %s", filepath, err)
+	}
+	f1.Sync()
+	f1.Close()
+}
+
+// TestExchangedataInWatchedDir test exchangedata operation on file in watched dir.
+func TestExchangedataInWatchedDir(t *testing.T) {
+	t.Parallel()
+	testExchangedataForWatcher(t, true)
+}
+
+// TestExchangedataInWatchedDir test exchangedata operation on watched file.
+func TestExchangedataInWatchedFile(t *testing.T) {
+	t.Parallel()
+	testExchangedataForWatcher(t, false)
+}
